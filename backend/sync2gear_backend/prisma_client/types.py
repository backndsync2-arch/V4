# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    role: _str
    avatar: Optional[_str]
    phone: Optional[_str]
    timezone: _str
    is_active: _bool
    is_staff: _bool
    is_superuser: _bool
    last_seen: Optional[datetime.datetime]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    tracks: 'TrackCreateManyNestedWithoutRelationsInput'
    schedules: 'ScheduleCreateManyNestedWithoutRelationsInput'
    announcements: 'AnnouncementCreateManyNestedWithoutRelationsInput'
    play_logs: 'PlayLogCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str
    name: _str
    password: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    role: _str
    avatar: Optional[_str]
    phone: Optional[_str]
    timezone: _str
    is_active: _bool
    is_staff: _bool
    is_superuser: _bool
    last_seen: Optional[datetime.datetime]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str
    name: _str
    password: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    email: _str
    name: _str
    password: _str
    role: _str
    avatar: Optional[_str]
    phone: Optional[_str]
    timezone: _str
    is_active: _bool
    is_staff: _bool
    is_superuser: _bool
    last_seen: Optional[datetime.datetime]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    tracks: 'TrackUpdateManyWithoutRelationsInput'
    schedules: 'ScheduleUpdateManyWithoutRelationsInput'
    announcements: 'AnnouncementUpdateManyWithoutRelationsInput'
    play_logs: 'PlayLogUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    email: _str
    name: _str
    password: _str
    role: _str
    avatar: Optional[_str]
    phone: Optional[_str]
    timezone: _str
    is_active: _bool
    is_staff: _bool
    is_superuser: _bool
    last_seen: Optional[datetime.datetime]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_name_OrderByInput = TypedDict(
    '_User_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_User_password_OrderByInput = TypedDict(
    '_User_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_User_role_OrderByInput = TypedDict(
    '_User_role_OrderByInput',
    {
        'role': 'SortOrder',
    },
    total=True
)

_User_avatar_OrderByInput = TypedDict(
    '_User_avatar_OrderByInput',
    {
        'avatar': 'SortOrder',
    },
    total=True
)

_User_phone_OrderByInput = TypedDict(
    '_User_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_User_timezone_OrderByInput = TypedDict(
    '_User_timezone_OrderByInput',
    {
        'timezone': 'SortOrder',
    },
    total=True
)

_User_is_active_OrderByInput = TypedDict(
    '_User_is_active_OrderByInput',
    {
        'is_active': 'SortOrder',
    },
    total=True
)

_User_is_staff_OrderByInput = TypedDict(
    '_User_is_staff_OrderByInput',
    {
        'is_staff': 'SortOrder',
    },
    total=True
)

_User_is_superuser_OrderByInput = TypedDict(
    '_User_is_superuser_OrderByInput',
    {
        'is_superuser': 'SortOrder',
    },
    total=True
)

_User_last_seen_OrderByInput = TypedDict(
    '_User_last_seen_OrderByInput',
    {
        'last_seen': 'SortOrder',
    },
    total=True
)

_User_created_at_OrderByInput = TypedDict(
    '_User_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_User_updated_at_OrderByInput = TypedDict(
    '_User_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_email_OrderByInput',
    '_User_name_OrderByInput',
    '_User_password_OrderByInput',
    '_User_role_OrderByInput',
    '_User_avatar_OrderByInput',
    '_User_phone_OrderByInput',
    '_User_timezone_OrderByInput',
    '_User_is_active_OrderByInput',
    '_User_is_staff_OrderByInput',
    '_User_is_superuser_OrderByInput',
    '_User_last_seen_OrderByInput',
    '_User_created_at_OrderByInput',
    '_User_updated_at_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    tracks: Union[bool, 'FindManyTrackArgsFromUser']
    schedules: Union[bool, 'FindManyScheduleArgsFromUser']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromUser']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUser']


    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tracks: Union[bool, 'FindManyTrackArgsFromUserRecursive1']
    schedules: Union[bool, 'FindManyScheduleArgsFromUserRecursive1']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromUserRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tracks: Union[bool, 'FindManyTrackArgsFromUserRecursive2']
    schedules: Union[bool, 'FindManyScheduleArgsFromUserRecursive2']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromUserRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tracks: Union[bool, 'FindManyTrackArgsFromUserRecursive3']
    schedules: Union[bool, 'FindManyScheduleArgsFromUserRecursive3']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromUserRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUserRecursive3']


class UserIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tracks: Union[bool, 'FindManyTrackArgsFromUserRecursive4']
    schedules: Union[bool, 'FindManyScheduleArgsFromUserRecursive4']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromUserRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUserRecursive4']


class UserIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TrackIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']


class TrackIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']


class TrackIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']


class TrackIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']


class TrackIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class TrackArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TrackIncludeFromTrackRecursive1'


class TrackArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'TrackIncludeFromTrackRecursive2'


class TrackArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'TrackIncludeFromTrackRecursive3'


class TrackArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'TrackIncludeFromTrackRecursive4'


class TrackArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyTrackArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive1'


class FindManyTrackArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive2'


class FindManyTrackArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive3'


class FindManyTrackArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive4'


class FindManyTrackArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    
    

class ScheduleIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']


class ScheduleIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']


class ScheduleIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']


class ScheduleIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']


class ScheduleIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class ScheduleArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ScheduleIncludeFromScheduleRecursive1'


class ScheduleArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ScheduleIncludeFromScheduleRecursive2'


class ScheduleArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'ScheduleIncludeFromScheduleRecursive3'


class ScheduleArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'ScheduleIncludeFromScheduleRecursive4'


class ScheduleArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyScheduleArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive1'


class FindManyScheduleArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive2'


class FindManyScheduleArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive3'


class FindManyScheduleArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive4'


class FindManyScheduleArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    
    

class AnnouncementIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUserRecursive1']


class AnnouncementIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUserRecursive2']


class AnnouncementIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUserRecursive3']


class AnnouncementIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromUserRecursive4']


class AnnouncementIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class AnnouncementArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class AnnouncementArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class AnnouncementArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class AnnouncementArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class AnnouncementArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyAnnouncementArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class FindManyAnnouncementArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class FindManyAnnouncementArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class FindManyAnnouncementArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class FindManyAnnouncementArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    
    

class PlayLogIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    announcement: Union[bool, 'AnnouncementArgsFromUserRecursive1']


class PlayLogIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    announcement: Union[bool, 'AnnouncementArgsFromUserRecursive2']


class PlayLogIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    announcement: Union[bool, 'AnnouncementArgsFromUserRecursive3']


class PlayLogIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    announcement: Union[bool, 'AnnouncementArgsFromUserRecursive4']


class PlayLogIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class PlayLogArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class PlayLogArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class PlayLogArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class PlayLogArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class PlayLogArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyPlayLogArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class FindManyPlayLogArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class FindManyPlayLogArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class FindManyPlayLogArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class FindManyPlayLogArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    avatar: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    timezone: Union[_str, 'types.StringFilter']
    is_active: Union[_bool, 'types.BooleanFilter']
    is_staff: Union[_bool, 'types.BooleanFilter']
    is_superuser: Union[_bool, 'types.BooleanFilter']
    last_seen: Union[None, datetime.datetime, 'types.DateTimeFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    tracks: 'TrackListRelationFilter'
    schedules: 'ScheduleListRelationFilter'
    announcements: 'AnnouncementListRelationFilter'
    play_logs: 'PlayLogListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    avatar: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    timezone: Union[_str, 'types.StringFilter']
    is_active: Union[_bool, 'types.BooleanFilter']
    is_staff: Union[_bool, 'types.BooleanFilter']
    is_superuser: Union[_bool, 'types.BooleanFilter']
    last_seen: Union[None, datetime.datetime, 'types.DateTimeFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    tracks: 'TrackListRelationFilter'
    schedules: 'ScheduleListRelationFilter'
    announcements: 'AnnouncementListRelationFilter'
    play_logs: 'PlayLogListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    avatar: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    timezone: Union[_str, 'types.StringFilter']
    is_active: Union[_bool, 'types.BooleanFilter']
    is_staff: Union[_bool, 'types.BooleanFilter']
    is_superuser: Union[_bool, 'types.BooleanFilter']
    last_seen: Union[None, datetime.datetime, 'types.DateTimeFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    tracks: 'TrackListRelationFilter'
    schedules: 'ScheduleListRelationFilter'
    announcements: 'AnnouncementListRelationFilter'
    play_logs: 'PlayLogListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive3', List['UserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive3']
    OR: List['UserWhereInputRecursive3']
    NOT: List['UserWhereInputRecursive3']


class UserWhereInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    avatar: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    timezone: Union[_str, 'types.StringFilter']
    is_active: Union[_bool, 'types.BooleanFilter']
    is_staff: Union[_bool, 'types.BooleanFilter']
    is_superuser: Union[_bool, 'types.BooleanFilter']
    last_seen: Union[None, datetime.datetime, 'types.DateTimeFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    tracks: 'TrackListRelationFilter'
    schedules: 'ScheduleListRelationFilter'
    announcements: 'AnnouncementListRelationFilter'
    play_logs: 'PlayLogListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive4', List['UserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive4']
    OR: List['UserWhereInputRecursive4']
    NOT: List['UserWhereInputRecursive4']


class UserWhereInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    avatar: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    timezone: Union[_str, 'types.StringFilter']
    is_active: Union[_bool, 'types.BooleanFilter']
    is_staff: Union[_bool, 'types.BooleanFilter']
    is_superuser: Union[_bool, 'types.BooleanFilter']
    last_seen: Union[None, datetime.datetime, 'types.DateTimeFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    tracks: 'TrackListRelationFilter'
    schedules: 'ScheduleListRelationFilter'
    announcements: 'AnnouncementListRelationFilter'
    play_logs: 'PlayLogListRelationFilter'



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    avatar: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    timezone: Union[_str, 'types.StringWithAggregatesFilter']
    is_active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_staff: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_superuser: Union[_bool, 'types.BooleanWithAggregatesFilter']
    last_seen: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    avatar: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    timezone: Union[_str, 'types.StringWithAggregatesFilter']
    is_active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_staff: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_superuser: Union[_bool, 'types.BooleanWithAggregatesFilter']
    last_seen: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    avatar: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    timezone: Union[_str, 'types.StringWithAggregatesFilter']
    is_active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_staff: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_superuser: Union[_bool, 'types.BooleanWithAggregatesFilter']
    last_seen: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive3']


class UserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    avatar: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    timezone: Union[_str, 'types.StringWithAggregatesFilter']
    is_active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_staff: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_superuser: Union[_bool, 'types.BooleanWithAggregatesFilter']
    last_seen: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive4']


class UserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    avatar: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    timezone: Union[_str, 'types.StringWithAggregatesFilter']
    is_active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_staff: Union[_bool, 'types.BooleanWithAggregatesFilter']
    is_superuser: Union[_bool, 'types.BooleanWithAggregatesFilter']
    last_seen: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    email: _str
    name: _str
    password: _str
    role: _str
    avatar: _str
    phone: _str
    timezone: _str
    is_active: _bool
    is_staff: _bool
    is_superuser: _bool
    last_seen: datetime.datetime
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    email: _str
    name: _str
    password: _str
    role: _str
    avatar: _str
    phone: _str
    timezone: _str
    is_active: _bool
    is_staff: _bool
    is_superuser: _bool
    last_seen: datetime.datetime
    created_at: datetime.datetime
    updated_at: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    email: bool
    name: bool
    password: bool
    role: bool
    avatar: bool
    phone: bool
    timezone: bool
    is_active: bool
    is_staff: bool
    is_superuser: bool
    last_seen: bool
    created_at: bool
    updated_at: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    email: bool
    name: bool
    password: bool
    role: bool
    avatar: bool
    phone: bool
    timezone: bool
    is_active: bool
    is_staff: bool
    is_superuser: bool
    last_seen: bool
    created_at: bool
    updated_at: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'name': bool,
        'password': bool,
        'role': bool,
        'avatar': bool,
        'phone': bool,
        'timezone': bool,
        'is_active': bool,
        'is_staff': bool,
        'is_superuser': bool,
        'last_seen': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'name': int,
        'password': int,
        'role': int,
        'avatar': int,
        'phone': int,
        'timezone': int,
        'is_active': int,
        'is_staff': int,
        'is_superuser': int,
        'last_seen': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'email',
    'name',
    'password',
    'role',
    'avatar',
    'phone',
    'timezone',
    'is_active',
    'is_staff',
    'is_superuser',
    'last_seen',
    'created_at',
    'updated_at',
    'tracks',
    'schedules',
    'announcements',
    'play_logs',
]
UserScalarFieldKeys = Literal[
    'id',
    'email',
    'name',
    'password',
    'role',
    'avatar',
    'phone',
    'timezone',
    'is_active',
    'is_staff',
    'is_superuser',
    'last_seen',
    'created_at',
    'updated_at',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'tracks',
        'schedules',
        'announcements',
        'play_logs',
    ]

# Track types

class TrackOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Track create method"""
    id: _str
    artist: Optional[_str]
    album: Optional[_str]
    genre: Optional[_str]
    year: Optional[_int]
    cover_art: Optional[_str]
    order: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: Optional[_str]
    user: 'UserCreateNestedWithoutRelationsInput'


class TrackCreateInput(TrackOptionalCreateInput):
    """Required arguments to the Track create method"""
    title: _str
    duration: _int
    filename: _str
    file_path: _str
    file_size: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TrackOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Track create method, without relations"""
    id: _str
    artist: Optional[_str]
    album: Optional[_str]
    genre: Optional[_str]
    year: Optional[_int]
    cover_art: Optional[_str]
    order: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: Optional[_str]


class TrackCreateWithoutRelationsInput(TrackOptionalCreateWithoutRelationsInput):
    """Required arguments to the Track create method, without relations"""
    title: _str
    duration: _int
    filename: _str
    file_path: _str
    file_size: _int

class TrackConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TrackCreateWithoutRelationsInput'
    where: 'TrackWhereUniqueInput'

class TrackCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TrackCreateWithoutRelationsInput'
    connect: 'TrackWhereUniqueInput'
    connect_or_create: 'TrackConnectOrCreateWithoutRelationsInput'


class TrackCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TrackCreateWithoutRelationsInput', List['TrackCreateWithoutRelationsInput']]
    connect: Union['TrackWhereUniqueInput', List['TrackWhereUniqueInput']]
    connect_or_create: Union['TrackConnectOrCreateWithoutRelationsInput', List['TrackConnectOrCreateWithoutRelationsInput']]

_TrackWhereUnique_id_Input = TypedDict(
    '_TrackWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TrackWhereUniqueInput = _TrackWhereUnique_id_Input


class TrackUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    title: _str
    artist: Optional[_str]
    album: Optional[_str]
    genre: Optional[_str]
    year: Optional[Union[AtomicIntInput, _int]]
    duration: Union[AtomicIntInput, _int]
    filename: _str
    file_path: _str
    file_size: Union[AtomicBigIntInput, _int]
    cover_art: Optional[_str]
    order: Union[AtomicIntInput, _int]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'


class TrackUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    title: _str
    artist: Optional[_str]
    album: Optional[_str]
    genre: Optional[_str]
    year: Optional[Union[AtomicIntInput, _int]]
    duration: Union[AtomicIntInput, _int]
    filename: _str
    file_path: _str
    file_size: Union[AtomicBigIntInput, _int]
    cover_art: Optional[_str]
    order: Union[AtomicIntInput, _int]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class TrackUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TrackCreateWithoutRelationsInput']
    connect: List['TrackWhereUniqueInput']
    connect_or_create: List['TrackConnectOrCreateWithoutRelationsInput']
    set: List['TrackWhereUniqueInput']
    disconnect: List['TrackWhereUniqueInput']
    delete: List['TrackWhereUniqueInput']

    # TODO
    # update: List['TrackUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TrackUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TrackScalarWhereInput']
    # upsert: List['TrackUpserteWithWhereUniqueWithoutRelationsInput']


class TrackUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TrackCreateWithoutRelationsInput'
    connect: 'TrackWhereUniqueInput'
    connect_or_create: 'TrackConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TrackUpdateInput'
    # upsert: 'TrackUpsertWithoutRelationsInput'


class TrackUpsertInput(TypedDict):
    create: 'TrackCreateInput'
    update: 'TrackUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Track_id_OrderByInput = TypedDict(
    '_Track_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Track_title_OrderByInput = TypedDict(
    '_Track_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Track_artist_OrderByInput = TypedDict(
    '_Track_artist_OrderByInput',
    {
        'artist': 'SortOrder',
    },
    total=True
)

_Track_album_OrderByInput = TypedDict(
    '_Track_album_OrderByInput',
    {
        'album': 'SortOrder',
    },
    total=True
)

_Track_genre_OrderByInput = TypedDict(
    '_Track_genre_OrderByInput',
    {
        'genre': 'SortOrder',
    },
    total=True
)

_Track_year_OrderByInput = TypedDict(
    '_Track_year_OrderByInput',
    {
        'year': 'SortOrder',
    },
    total=True
)

_Track_duration_OrderByInput = TypedDict(
    '_Track_duration_OrderByInput',
    {
        'duration': 'SortOrder',
    },
    total=True
)

_Track_filename_OrderByInput = TypedDict(
    '_Track_filename_OrderByInput',
    {
        'filename': 'SortOrder',
    },
    total=True
)

_Track_file_path_OrderByInput = TypedDict(
    '_Track_file_path_OrderByInput',
    {
        'file_path': 'SortOrder',
    },
    total=True
)

_Track_file_size_OrderByInput = TypedDict(
    '_Track_file_size_OrderByInput',
    {
        'file_size': 'SortOrder',
    },
    total=True
)

_Track_cover_art_OrderByInput = TypedDict(
    '_Track_cover_art_OrderByInput',
    {
        'cover_art': 'SortOrder',
    },
    total=True
)

_Track_order_OrderByInput = TypedDict(
    '_Track_order_OrderByInput',
    {
        'order': 'SortOrder',
    },
    total=True
)

_Track_created_at_OrderByInput = TypedDict(
    '_Track_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Track_updated_at_OrderByInput = TypedDict(
    '_Track_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_Track_user_id_OrderByInput = TypedDict(
    '_Track_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_Track_RelevanceInner = TypedDict(
    '_Track_RelevanceInner',
    {
        'fields': 'List[TrackScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Track_RelevanceOrderByInput = TypedDict(
    '_Track_RelevanceOrderByInput',
    {
        '_relevance': '_Track_RelevanceInner',
    },
    total=True
)

TrackOrderByInput = Union[
    '_Track_id_OrderByInput',
    '_Track_title_OrderByInput',
    '_Track_artist_OrderByInput',
    '_Track_album_OrderByInput',
    '_Track_genre_OrderByInput',
    '_Track_year_OrderByInput',
    '_Track_duration_OrderByInput',
    '_Track_filename_OrderByInput',
    '_Track_file_path_OrderByInput',
    '_Track_file_size_OrderByInput',
    '_Track_cover_art_OrderByInput',
    '_Track_order_OrderByInput',
    '_Track_created_at_OrderByInput',
    '_Track_updated_at_OrderByInput',
    '_Track_user_id_OrderByInput',
    '_Track_RelevanceOrderByInput',
]



# recursive Track types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TrackRelationFilter = TypedDict(
    'TrackRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TrackListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TrackInclude(TypedDict, total=False):
    """Track relational arguments"""
    user: Union[bool, 'UserArgsFromTrack']


    

class UserIncludeFromTrack(TypedDict, total=False):
    """Relational arguments for Track"""
    tracks: Union[bool, 'FindManyTrackArgsFromTrackRecursive1']
    schedules: Union[bool, 'FindManyScheduleArgsFromTrackRecursive1']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromTrackRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromTrackRecursive1']


class UserIncludeFromTrackRecursive1(TypedDict, total=False):
    """Relational arguments for Track"""
    tracks: Union[bool, 'FindManyTrackArgsFromTrackRecursive2']
    schedules: Union[bool, 'FindManyScheduleArgsFromTrackRecursive2']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromTrackRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromTrackRecursive2']


class UserIncludeFromTrackRecursive2(TypedDict, total=False):
    """Relational arguments for Track"""
    tracks: Union[bool, 'FindManyTrackArgsFromTrackRecursive3']
    schedules: Union[bool, 'FindManyScheduleArgsFromTrackRecursive3']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromTrackRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromTrackRecursive3']


class UserIncludeFromTrackRecursive3(TypedDict, total=False):
    """Relational arguments for Track"""
    tracks: Union[bool, 'FindManyTrackArgsFromTrackRecursive4']
    schedules: Union[bool, 'FindManyScheduleArgsFromTrackRecursive4']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromTrackRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromTrackRecursive4']


class UserIncludeFromTrackRecursive4(TypedDict, total=False):
    """Relational arguments for Track"""

    

class UserArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    
    

class FindManyUserArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TrackIncludeFromTrack(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive1']


class TrackIncludeFromTrackRecursive1(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive2']


class TrackIncludeFromTrackRecursive2(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive3']


class TrackIncludeFromTrackRecursive3(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive4']


class TrackIncludeFromTrackRecursive4(TypedDict, total=False):
    """Relational arguments for Track"""

    

class TrackArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    include: 'TrackIncludeFromTrackRecursive1'


class TrackArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    include: 'TrackIncludeFromTrackRecursive2'


class TrackArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    include: 'TrackIncludeFromTrackRecursive3'


class TrackArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    include: 'TrackIncludeFromTrackRecursive4'


class TrackArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    
    

class FindManyTrackArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive1'


class FindManyTrackArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive2'


class FindManyTrackArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive3'


class FindManyTrackArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive4'


class FindManyTrackArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    
    

class ScheduleIncludeFromTrack(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive1']


class ScheduleIncludeFromTrackRecursive1(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive2']


class ScheduleIncludeFromTrackRecursive2(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive3']


class ScheduleIncludeFromTrackRecursive3(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive4']


class ScheduleIncludeFromTrackRecursive4(TypedDict, total=False):
    """Relational arguments for Track"""

    

class ScheduleArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    include: 'ScheduleIncludeFromScheduleRecursive1'


class ScheduleArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    include: 'ScheduleIncludeFromScheduleRecursive2'


class ScheduleArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    include: 'ScheduleIncludeFromScheduleRecursive3'


class ScheduleArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    include: 'ScheduleIncludeFromScheduleRecursive4'


class ScheduleArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    
    

class FindManyScheduleArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive1'


class FindManyScheduleArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive2'


class FindManyScheduleArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive3'


class FindManyScheduleArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive4'


class FindManyScheduleArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    
    

class AnnouncementIncludeFromTrack(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromTrackRecursive1']


class AnnouncementIncludeFromTrackRecursive1(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromTrackRecursive2']


class AnnouncementIncludeFromTrackRecursive2(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromTrackRecursive3']


class AnnouncementIncludeFromTrackRecursive3(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromTrackRecursive4']


class AnnouncementIncludeFromTrackRecursive4(TypedDict, total=False):
    """Relational arguments for Track"""

    

class AnnouncementArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class AnnouncementArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class AnnouncementArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class AnnouncementArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class AnnouncementArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    
    

class FindManyAnnouncementArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class FindManyAnnouncementArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class FindManyAnnouncementArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class FindManyAnnouncementArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class FindManyAnnouncementArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    
    

class PlayLogIncludeFromTrack(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive1']
    announcement: Union[bool, 'AnnouncementArgsFromTrackRecursive1']


class PlayLogIncludeFromTrackRecursive1(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive2']
    announcement: Union[bool, 'AnnouncementArgsFromTrackRecursive2']


class PlayLogIncludeFromTrackRecursive2(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive3']
    announcement: Union[bool, 'AnnouncementArgsFromTrackRecursive3']


class PlayLogIncludeFromTrackRecursive3(TypedDict, total=False):
    """Relational arguments for Track"""
    user: Union[bool, 'UserArgsFromTrackRecursive4']
    announcement: Union[bool, 'AnnouncementArgsFromTrackRecursive4']


class PlayLogIncludeFromTrackRecursive4(TypedDict, total=False):
    """Relational arguments for Track"""

    

class PlayLogArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class PlayLogArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class PlayLogArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class PlayLogArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class PlayLogArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    
    

class FindManyPlayLogArgsFromTrack(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class FindManyPlayLogArgsFromTrackRecursive1(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class FindManyPlayLogArgsFromTrackRecursive2(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class FindManyPlayLogArgsFromTrackRecursive3(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class FindManyPlayLogArgsFromTrackRecursive4(TypedDict, total=False):
    """Arguments for Track"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    


FindManyTrackArgs = FindManyTrackArgsFromTrack
FindFirstTrackArgs = FindManyTrackArgsFromTrack


    

class TrackWhereInput(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    artist: Union[None, _str, 'types.StringFilter']
    album: Union[None, _str, 'types.StringFilter']
    genre: Union[None, _str, 'types.StringFilter']
    year: Union[None, _int, 'types.IntFilter']
    duration: Union[_int, 'types.IntFilter']
    filename: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    cover_art: Union[None, _str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['TrackWhereInputRecursive1', List['TrackWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TrackWhereInputRecursive1']
    OR: List['TrackWhereInputRecursive1']
    NOT: List['TrackWhereInputRecursive1']


class TrackWhereInputRecursive1(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    artist: Union[None, _str, 'types.StringFilter']
    album: Union[None, _str, 'types.StringFilter']
    genre: Union[None, _str, 'types.StringFilter']
    year: Union[None, _int, 'types.IntFilter']
    duration: Union[_int, 'types.IntFilter']
    filename: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    cover_art: Union[None, _str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['TrackWhereInputRecursive2', List['TrackWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TrackWhereInputRecursive2']
    OR: List['TrackWhereInputRecursive2']
    NOT: List['TrackWhereInputRecursive2']


class TrackWhereInputRecursive2(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    artist: Union[None, _str, 'types.StringFilter']
    album: Union[None, _str, 'types.StringFilter']
    genre: Union[None, _str, 'types.StringFilter']
    year: Union[None, _int, 'types.IntFilter']
    duration: Union[_int, 'types.IntFilter']
    filename: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    cover_art: Union[None, _str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['TrackWhereInputRecursive3', List['TrackWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TrackWhereInputRecursive3']
    OR: List['TrackWhereInputRecursive3']
    NOT: List['TrackWhereInputRecursive3']


class TrackWhereInputRecursive3(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    artist: Union[None, _str, 'types.StringFilter']
    album: Union[None, _str, 'types.StringFilter']
    genre: Union[None, _str, 'types.StringFilter']
    year: Union[None, _int, 'types.IntFilter']
    duration: Union[_int, 'types.IntFilter']
    filename: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    cover_art: Union[None, _str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['TrackWhereInputRecursive4', List['TrackWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TrackWhereInputRecursive4']
    OR: List['TrackWhereInputRecursive4']
    NOT: List['TrackWhereInputRecursive4']


class TrackWhereInputRecursive4(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    artist: Union[None, _str, 'types.StringFilter']
    album: Union[None, _str, 'types.StringFilter']
    genre: Union[None, _str, 'types.StringFilter']
    year: Union[None, _int, 'types.IntFilter']
    duration: Union[_int, 'types.IntFilter']
    filename: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    cover_art: Union[None, _str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'



# aggregate Track types


    

class TrackScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    artist: Union[_str, 'types.StringWithAggregatesFilter']
    album: Union[_str, 'types.StringWithAggregatesFilter']
    genre: Union[_str, 'types.StringWithAggregatesFilter']
    year: Union[_int, 'types.IntWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    cover_art: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TrackScalarWhereWithAggregatesInputRecursive1']
    OR: List['TrackScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TrackScalarWhereWithAggregatesInputRecursive1']


class TrackScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    artist: Union[_str, 'types.StringWithAggregatesFilter']
    album: Union[_str, 'types.StringWithAggregatesFilter']
    genre: Union[_str, 'types.StringWithAggregatesFilter']
    year: Union[_int, 'types.IntWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    cover_art: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TrackScalarWhereWithAggregatesInputRecursive2']
    OR: List['TrackScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TrackScalarWhereWithAggregatesInputRecursive2']


class TrackScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    artist: Union[_str, 'types.StringWithAggregatesFilter']
    album: Union[_str, 'types.StringWithAggregatesFilter']
    genre: Union[_str, 'types.StringWithAggregatesFilter']
    year: Union[_int, 'types.IntWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    cover_art: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TrackScalarWhereWithAggregatesInputRecursive3']
    OR: List['TrackScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TrackScalarWhereWithAggregatesInputRecursive3']


class TrackScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    artist: Union[_str, 'types.StringWithAggregatesFilter']
    album: Union[_str, 'types.StringWithAggregatesFilter']
    genre: Union[_str, 'types.StringWithAggregatesFilter']
    year: Union[_int, 'types.IntWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    cover_art: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TrackScalarWhereWithAggregatesInputRecursive4']
    OR: List['TrackScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TrackScalarWhereWithAggregatesInputRecursive4']


class TrackScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Track arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    artist: Union[_str, 'types.StringWithAggregatesFilter']
    album: Union[_str, 'types.StringWithAggregatesFilter']
    genre: Union[_str, 'types.StringWithAggregatesFilter']
    year: Union[_int, 'types.IntWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    cover_art: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']



class TrackGroupByOutput(TypedDict, total=False):
    id: _str
    title: _str
    artist: _str
    album: _str
    genre: _str
    year: _int
    duration: _int
    filename: _str
    file_path: _str
    file_size: _int
    cover_art: _str
    order: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: _str
    _sum: 'TrackSumAggregateOutput'
    _avg: 'TrackAvgAggregateOutput'
    _min: 'TrackMinAggregateOutput'
    _max: 'TrackMaxAggregateOutput'
    _count: 'TrackCountAggregateOutput'


class TrackAvgAggregateOutput(TypedDict, total=False):
    """Track output for aggregating averages"""
    year: float
    duration: float
    file_size: float
    order: float


class TrackSumAggregateOutput(TypedDict, total=False):
    """Track output for aggregating sums"""
    year: _int
    duration: _int
    file_size: _int
    order: _int


class TrackScalarAggregateOutput(TypedDict, total=False):
    """Track output including scalar fields"""
    id: _str
    title: _str
    artist: _str
    album: _str
    genre: _str
    year: _int
    duration: _int
    filename: _str
    file_path: _str
    file_size: _int
    cover_art: _str
    order: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: _str


TrackMinAggregateOutput = TrackScalarAggregateOutput
TrackMaxAggregateOutput = TrackScalarAggregateOutput


class TrackMaxAggregateInput(TypedDict, total=False):
    """Track input for aggregating by max"""
    id: bool
    title: bool
    artist: bool
    album: bool
    genre: bool
    year: bool
    duration: bool
    filename: bool
    file_path: bool
    file_size: bool
    cover_art: bool
    order: bool
    created_at: bool
    updated_at: bool
    user_id: bool


class TrackMinAggregateInput(TypedDict, total=False):
    """Track input for aggregating by min"""
    id: bool
    title: bool
    artist: bool
    album: bool
    genre: bool
    year: bool
    duration: bool
    filename: bool
    file_path: bool
    file_size: bool
    cover_art: bool
    order: bool
    created_at: bool
    updated_at: bool
    user_id: bool


class TrackNumberAggregateInput(TypedDict, total=False):
    """Track input for aggregating numbers"""
    year: bool
    duration: bool
    file_size: bool
    order: bool


TrackAvgAggregateInput = TrackNumberAggregateInput
TrackSumAggregateInput = TrackNumberAggregateInput


TrackCountAggregateInput = TypedDict(
    'TrackCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'artist': bool,
        'album': bool,
        'genre': bool,
        'year': bool,
        'duration': bool,
        'filename': bool,
        'file_path': bool,
        'file_size': bool,
        'cover_art': bool,
        'order': bool,
        'created_at': bool,
        'updated_at': bool,
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

TrackCountAggregateOutput = TypedDict(
    'TrackCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'artist': int,
        'album': int,
        'genre': int,
        'year': int,
        'duration': int,
        'filename': int,
        'file_path': int,
        'file_size': int,
        'cover_art': int,
        'order': int,
        'created_at': int,
        'updated_at': int,
        'user_id': int,
        '_all': int,
    },
    total=False,
)


TrackKeys = Literal[
    'id',
    'title',
    'artist',
    'album',
    'genre',
    'year',
    'duration',
    'filename',
    'file_path',
    'file_size',
    'cover_art',
    'order',
    'created_at',
    'updated_at',
    'user_id',
    'user',
]
TrackScalarFieldKeys = Literal[
    'id',
    'title',
    'artist',
    'album',
    'genre',
    'year',
    'duration',
    'filename',
    'file_path',
    'file_size',
    'cover_art',
    'order',
    'created_at',
    'updated_at',
    'user_id',
]
TrackScalarFieldKeysT = TypeVar('TrackScalarFieldKeysT', bound=TrackScalarFieldKeys)

TrackRelationalFieldKeys = Literal[
        'user',
    ]

# Schedule types

class ScheduleOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Schedule create method"""
    id: _str
    enabled: _bool
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: Optional[_str]
    user: 'UserCreateNestedWithoutRelationsInput'


class ScheduleCreateInput(ScheduleOptionalCreateInput):
    """Required arguments to the Schedule create method"""
    name: _str
    type: _str
    mode: _str
    config: 'fields.Json'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ScheduleOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Schedule create method, without relations"""
    id: _str
    enabled: _bool
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: Optional[_str]


class ScheduleCreateWithoutRelationsInput(ScheduleOptionalCreateWithoutRelationsInput):
    """Required arguments to the Schedule create method, without relations"""
    name: _str
    type: _str
    mode: _str
    config: 'fields.Json'

class ScheduleConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ScheduleCreateWithoutRelationsInput'
    where: 'ScheduleWhereUniqueInput'

class ScheduleCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ScheduleCreateWithoutRelationsInput'
    connect: 'ScheduleWhereUniqueInput'
    connect_or_create: 'ScheduleConnectOrCreateWithoutRelationsInput'


class ScheduleCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ScheduleCreateWithoutRelationsInput', List['ScheduleCreateWithoutRelationsInput']]
    connect: Union['ScheduleWhereUniqueInput', List['ScheduleWhereUniqueInput']]
    connect_or_create: Union['ScheduleConnectOrCreateWithoutRelationsInput', List['ScheduleConnectOrCreateWithoutRelationsInput']]

_ScheduleWhereUnique_id_Input = TypedDict(
    '_ScheduleWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ScheduleWhereUniqueInput = _ScheduleWhereUnique_id_Input


class ScheduleUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    type: _str
    mode: _str
    config: 'fields.Json'
    enabled: _bool
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'


class ScheduleUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    type: _str
    mode: _str
    config: 'fields.Json'
    enabled: _bool
    created_at: datetime.datetime
    updated_at: datetime.datetime


class ScheduleUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ScheduleCreateWithoutRelationsInput']
    connect: List['ScheduleWhereUniqueInput']
    connect_or_create: List['ScheduleConnectOrCreateWithoutRelationsInput']
    set: List['ScheduleWhereUniqueInput']
    disconnect: List['ScheduleWhereUniqueInput']
    delete: List['ScheduleWhereUniqueInput']

    # TODO
    # update: List['ScheduleUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ScheduleUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ScheduleScalarWhereInput']
    # upsert: List['ScheduleUpserteWithWhereUniqueWithoutRelationsInput']


class ScheduleUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ScheduleCreateWithoutRelationsInput'
    connect: 'ScheduleWhereUniqueInput'
    connect_or_create: 'ScheduleConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ScheduleUpdateInput'
    # upsert: 'ScheduleUpsertWithoutRelationsInput'


class ScheduleUpsertInput(TypedDict):
    create: 'ScheduleCreateInput'
    update: 'ScheduleUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Schedule_id_OrderByInput = TypedDict(
    '_Schedule_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Schedule_name_OrderByInput = TypedDict(
    '_Schedule_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Schedule_type_OrderByInput = TypedDict(
    '_Schedule_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Schedule_mode_OrderByInput = TypedDict(
    '_Schedule_mode_OrderByInput',
    {
        'mode': 'SortOrder',
    },
    total=True
)

_Schedule_config_OrderByInput = TypedDict(
    '_Schedule_config_OrderByInput',
    {
        'config': 'SortOrder',
    },
    total=True
)

_Schedule_enabled_OrderByInput = TypedDict(
    '_Schedule_enabled_OrderByInput',
    {
        'enabled': 'SortOrder',
    },
    total=True
)

_Schedule_created_at_OrderByInput = TypedDict(
    '_Schedule_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Schedule_updated_at_OrderByInput = TypedDict(
    '_Schedule_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_Schedule_user_id_OrderByInput = TypedDict(
    '_Schedule_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_Schedule_RelevanceInner = TypedDict(
    '_Schedule_RelevanceInner',
    {
        'fields': 'List[ScheduleScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Schedule_RelevanceOrderByInput = TypedDict(
    '_Schedule_RelevanceOrderByInput',
    {
        '_relevance': '_Schedule_RelevanceInner',
    },
    total=True
)

ScheduleOrderByInput = Union[
    '_Schedule_id_OrderByInput',
    '_Schedule_name_OrderByInput',
    '_Schedule_type_OrderByInput',
    '_Schedule_mode_OrderByInput',
    '_Schedule_config_OrderByInput',
    '_Schedule_enabled_OrderByInput',
    '_Schedule_created_at_OrderByInput',
    '_Schedule_updated_at_OrderByInput',
    '_Schedule_user_id_OrderByInput',
    '_Schedule_RelevanceOrderByInput',
]



# recursive Schedule types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ScheduleRelationFilter = TypedDict(
    'ScheduleRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ScheduleListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ScheduleInclude(TypedDict, total=False):
    """Schedule relational arguments"""
    user: Union[bool, 'UserArgsFromSchedule']


    

class UserIncludeFromSchedule(TypedDict, total=False):
    """Relational arguments for Schedule"""
    tracks: Union[bool, 'FindManyTrackArgsFromScheduleRecursive1']
    schedules: Union[bool, 'FindManyScheduleArgsFromScheduleRecursive1']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromScheduleRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromScheduleRecursive1']


class UserIncludeFromScheduleRecursive1(TypedDict, total=False):
    """Relational arguments for Schedule"""
    tracks: Union[bool, 'FindManyTrackArgsFromScheduleRecursive2']
    schedules: Union[bool, 'FindManyScheduleArgsFromScheduleRecursive2']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromScheduleRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromScheduleRecursive2']


class UserIncludeFromScheduleRecursive2(TypedDict, total=False):
    """Relational arguments for Schedule"""
    tracks: Union[bool, 'FindManyTrackArgsFromScheduleRecursive3']
    schedules: Union[bool, 'FindManyScheduleArgsFromScheduleRecursive3']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromScheduleRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromScheduleRecursive3']


class UserIncludeFromScheduleRecursive3(TypedDict, total=False):
    """Relational arguments for Schedule"""
    tracks: Union[bool, 'FindManyTrackArgsFromScheduleRecursive4']
    schedules: Union[bool, 'FindManyScheduleArgsFromScheduleRecursive4']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromScheduleRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromScheduleRecursive4']


class UserIncludeFromScheduleRecursive4(TypedDict, total=False):
    """Relational arguments for Schedule"""

    

class UserArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    
    

class FindManyUserArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TrackIncludeFromSchedule(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive1']


class TrackIncludeFromScheduleRecursive1(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive2']


class TrackIncludeFromScheduleRecursive2(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive3']


class TrackIncludeFromScheduleRecursive3(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive4']


class TrackIncludeFromScheduleRecursive4(TypedDict, total=False):
    """Relational arguments for Schedule"""

    

class TrackArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'TrackIncludeFromTrackRecursive1'


class TrackArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'TrackIncludeFromTrackRecursive2'


class TrackArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'TrackIncludeFromTrackRecursive3'


class TrackArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'TrackIncludeFromTrackRecursive4'


class TrackArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    
    

class FindManyTrackArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive1'


class FindManyTrackArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive2'


class FindManyTrackArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive3'


class FindManyTrackArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive4'


class FindManyTrackArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    
    

class ScheduleIncludeFromSchedule(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive1']


class ScheduleIncludeFromScheduleRecursive1(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive2']


class ScheduleIncludeFromScheduleRecursive2(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive3']


class ScheduleIncludeFromScheduleRecursive3(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive4']


class ScheduleIncludeFromScheduleRecursive4(TypedDict, total=False):
    """Relational arguments for Schedule"""

    

class ScheduleArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'ScheduleIncludeFromScheduleRecursive1'


class ScheduleArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'ScheduleIncludeFromScheduleRecursive2'


class ScheduleArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'ScheduleIncludeFromScheduleRecursive3'


class ScheduleArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'ScheduleIncludeFromScheduleRecursive4'


class ScheduleArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    
    

class FindManyScheduleArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive1'


class FindManyScheduleArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive2'


class FindManyScheduleArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive3'


class FindManyScheduleArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive4'


class FindManyScheduleArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    
    

class AnnouncementIncludeFromSchedule(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromScheduleRecursive1']


class AnnouncementIncludeFromScheduleRecursive1(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromScheduleRecursive2']


class AnnouncementIncludeFromScheduleRecursive2(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromScheduleRecursive3']


class AnnouncementIncludeFromScheduleRecursive3(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromScheduleRecursive4']


class AnnouncementIncludeFromScheduleRecursive4(TypedDict, total=False):
    """Relational arguments for Schedule"""

    

class AnnouncementArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class AnnouncementArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class AnnouncementArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class AnnouncementArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class AnnouncementArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    
    

class FindManyAnnouncementArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class FindManyAnnouncementArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class FindManyAnnouncementArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class FindManyAnnouncementArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class FindManyAnnouncementArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    
    

class PlayLogIncludeFromSchedule(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive1']
    announcement: Union[bool, 'AnnouncementArgsFromScheduleRecursive1']


class PlayLogIncludeFromScheduleRecursive1(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive2']
    announcement: Union[bool, 'AnnouncementArgsFromScheduleRecursive2']


class PlayLogIncludeFromScheduleRecursive2(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive3']
    announcement: Union[bool, 'AnnouncementArgsFromScheduleRecursive3']


class PlayLogIncludeFromScheduleRecursive3(TypedDict, total=False):
    """Relational arguments for Schedule"""
    user: Union[bool, 'UserArgsFromScheduleRecursive4']
    announcement: Union[bool, 'AnnouncementArgsFromScheduleRecursive4']


class PlayLogIncludeFromScheduleRecursive4(TypedDict, total=False):
    """Relational arguments for Schedule"""

    

class PlayLogArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class PlayLogArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class PlayLogArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class PlayLogArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class PlayLogArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    
    

class FindManyPlayLogArgsFromSchedule(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class FindManyPlayLogArgsFromScheduleRecursive1(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class FindManyPlayLogArgsFromScheduleRecursive2(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class FindManyPlayLogArgsFromScheduleRecursive3(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class FindManyPlayLogArgsFromScheduleRecursive4(TypedDict, total=False):
    """Arguments for Schedule"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    


FindManyScheduleArgs = FindManyScheduleArgsFromSchedule
FindFirstScheduleArgs = FindManyScheduleArgsFromSchedule


    

class ScheduleWhereInput(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    mode: Union[_str, 'types.StringFilter']
    config: Union['fields.Json', 'types.JsonFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['ScheduleWhereInputRecursive1', List['ScheduleWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ScheduleWhereInputRecursive1']
    OR: List['ScheduleWhereInputRecursive1']
    NOT: List['ScheduleWhereInputRecursive1']


class ScheduleWhereInputRecursive1(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    mode: Union[_str, 'types.StringFilter']
    config: Union['fields.Json', 'types.JsonFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['ScheduleWhereInputRecursive2', List['ScheduleWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ScheduleWhereInputRecursive2']
    OR: List['ScheduleWhereInputRecursive2']
    NOT: List['ScheduleWhereInputRecursive2']


class ScheduleWhereInputRecursive2(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    mode: Union[_str, 'types.StringFilter']
    config: Union['fields.Json', 'types.JsonFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['ScheduleWhereInputRecursive3', List['ScheduleWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ScheduleWhereInputRecursive3']
    OR: List['ScheduleWhereInputRecursive3']
    NOT: List['ScheduleWhereInputRecursive3']


class ScheduleWhereInputRecursive3(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    mode: Union[_str, 'types.StringFilter']
    config: Union['fields.Json', 'types.JsonFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['ScheduleWhereInputRecursive4', List['ScheduleWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ScheduleWhereInputRecursive4']
    OR: List['ScheduleWhereInputRecursive4']
    NOT: List['ScheduleWhereInputRecursive4']


class ScheduleWhereInputRecursive4(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    mode: Union[_str, 'types.StringFilter']
    config: Union['fields.Json', 'types.JsonFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'



# aggregate Schedule types


    

class ScheduleScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    mode: Union[_str, 'types.StringWithAggregatesFilter']
    config: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ScheduleScalarWhereWithAggregatesInputRecursive1']
    OR: List['ScheduleScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ScheduleScalarWhereWithAggregatesInputRecursive1']


class ScheduleScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    mode: Union[_str, 'types.StringWithAggregatesFilter']
    config: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ScheduleScalarWhereWithAggregatesInputRecursive2']
    OR: List['ScheduleScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ScheduleScalarWhereWithAggregatesInputRecursive2']


class ScheduleScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    mode: Union[_str, 'types.StringWithAggregatesFilter']
    config: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ScheduleScalarWhereWithAggregatesInputRecursive3']
    OR: List['ScheduleScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ScheduleScalarWhereWithAggregatesInputRecursive3']


class ScheduleScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    mode: Union[_str, 'types.StringWithAggregatesFilter']
    config: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ScheduleScalarWhereWithAggregatesInputRecursive4']
    OR: List['ScheduleScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ScheduleScalarWhereWithAggregatesInputRecursive4']


class ScheduleScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Schedule arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    mode: Union[_str, 'types.StringWithAggregatesFilter']
    config: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']



class ScheduleGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    type: _str
    mode: _str
    config: 'fields.Json'
    enabled: _bool
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: _str
    _sum: 'ScheduleSumAggregateOutput'
    _avg: 'ScheduleAvgAggregateOutput'
    _min: 'ScheduleMinAggregateOutput'
    _max: 'ScheduleMaxAggregateOutput'
    _count: 'ScheduleCountAggregateOutput'


class ScheduleAvgAggregateOutput(TypedDict, total=False):
    """Schedule output for aggregating averages"""


class ScheduleSumAggregateOutput(TypedDict, total=False):
    """Schedule output for aggregating sums"""


class ScheduleScalarAggregateOutput(TypedDict, total=False):
    """Schedule output including scalar fields"""
    id: _str
    name: _str
    type: _str
    mode: _str
    config: 'fields.Json'
    enabled: _bool
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: _str


ScheduleMinAggregateOutput = ScheduleScalarAggregateOutput
ScheduleMaxAggregateOutput = ScheduleScalarAggregateOutput


class ScheduleMaxAggregateInput(TypedDict, total=False):
    """Schedule input for aggregating by max"""
    id: bool
    name: bool
    type: bool
    mode: bool
    config: bool
    enabled: bool
    created_at: bool
    updated_at: bool
    user_id: bool


class ScheduleMinAggregateInput(TypedDict, total=False):
    """Schedule input for aggregating by min"""
    id: bool
    name: bool
    type: bool
    mode: bool
    config: bool
    enabled: bool
    created_at: bool
    updated_at: bool
    user_id: bool


class ScheduleNumberAggregateInput(TypedDict, total=False):
    """Schedule input for aggregating numbers"""


ScheduleAvgAggregateInput = ScheduleNumberAggregateInput
ScheduleSumAggregateInput = ScheduleNumberAggregateInput


ScheduleCountAggregateInput = TypedDict(
    'ScheduleCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'type': bool,
        'mode': bool,
        'config': bool,
        'enabled': bool,
        'created_at': bool,
        'updated_at': bool,
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

ScheduleCountAggregateOutput = TypedDict(
    'ScheduleCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'type': int,
        'mode': int,
        'config': int,
        'enabled': int,
        'created_at': int,
        'updated_at': int,
        'user_id': int,
        '_all': int,
    },
    total=False,
)


ScheduleKeys = Literal[
    'id',
    'name',
    'type',
    'mode',
    'config',
    'enabled',
    'created_at',
    'updated_at',
    'user_id',
    'user',
]
ScheduleScalarFieldKeys = Literal[
    'id',
    'name',
    'type',
    'mode',
    'config',
    'enabled',
    'created_at',
    'updated_at',
    'user_id',
]
ScheduleScalarFieldKeysT = TypeVar('ScheduleScalarFieldKeysT', bound=ScheduleScalarFieldKeys)

ScheduleRelationalFieldKeys = Literal[
        'user',
    ]

# Announcement types

class AnnouncementOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Announcement create method"""
    id: _str
    is_tts: _bool
    tts_text: Optional[_str]
    tts_voice: Optional[_str]
    is_recording: _bool
    enabled: _bool
    category: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: Optional[_str]
    user: 'UserCreateNestedWithoutRelationsInput'
    play_logs: 'PlayLogCreateManyNestedWithoutRelationsInput'


class AnnouncementCreateInput(AnnouncementOptionalCreateInput):
    """Required arguments to the Announcement create method"""
    title: _str
    file_path: _str
    duration: _int
    file_size: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AnnouncementOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Announcement create method, without relations"""
    id: _str
    is_tts: _bool
    tts_text: Optional[_str]
    tts_voice: Optional[_str]
    is_recording: _bool
    enabled: _bool
    category: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: Optional[_str]


class AnnouncementCreateWithoutRelationsInput(AnnouncementOptionalCreateWithoutRelationsInput):
    """Required arguments to the Announcement create method, without relations"""
    title: _str
    file_path: _str
    duration: _int
    file_size: _int

class AnnouncementConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AnnouncementCreateWithoutRelationsInput'
    where: 'AnnouncementWhereUniqueInput'

class AnnouncementCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AnnouncementCreateWithoutRelationsInput'
    connect: 'AnnouncementWhereUniqueInput'
    connect_or_create: 'AnnouncementConnectOrCreateWithoutRelationsInput'


class AnnouncementCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AnnouncementCreateWithoutRelationsInput', List['AnnouncementCreateWithoutRelationsInput']]
    connect: Union['AnnouncementWhereUniqueInput', List['AnnouncementWhereUniqueInput']]
    connect_or_create: Union['AnnouncementConnectOrCreateWithoutRelationsInput', List['AnnouncementConnectOrCreateWithoutRelationsInput']]

_AnnouncementWhereUnique_id_Input = TypedDict(
    '_AnnouncementWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

AnnouncementWhereUniqueInput = _AnnouncementWhereUnique_id_Input


class AnnouncementUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    title: _str
    file_path: _str
    duration: Union[AtomicIntInput, _int]
    file_size: Union[AtomicBigIntInput, _int]
    is_tts: _bool
    tts_text: Optional[_str]
    tts_voice: Optional[_str]
    is_recording: _bool
    enabled: _bool
    category: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    play_logs: 'PlayLogUpdateManyWithoutRelationsInput'


class AnnouncementUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    title: _str
    file_path: _str
    duration: Union[AtomicIntInput, _int]
    file_size: Union[AtomicBigIntInput, _int]
    is_tts: _bool
    tts_text: Optional[_str]
    tts_voice: Optional[_str]
    is_recording: _bool
    enabled: _bool
    category: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class AnnouncementUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AnnouncementCreateWithoutRelationsInput']
    connect: List['AnnouncementWhereUniqueInput']
    connect_or_create: List['AnnouncementConnectOrCreateWithoutRelationsInput']
    set: List['AnnouncementWhereUniqueInput']
    disconnect: List['AnnouncementWhereUniqueInput']
    delete: List['AnnouncementWhereUniqueInput']

    # TODO
    # update: List['AnnouncementUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AnnouncementUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AnnouncementScalarWhereInput']
    # upsert: List['AnnouncementUpserteWithWhereUniqueWithoutRelationsInput']


class AnnouncementUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AnnouncementCreateWithoutRelationsInput'
    connect: 'AnnouncementWhereUniqueInput'
    connect_or_create: 'AnnouncementConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AnnouncementUpdateInput'
    # upsert: 'AnnouncementUpsertWithoutRelationsInput'


class AnnouncementUpsertInput(TypedDict):
    create: 'AnnouncementCreateInput'
    update: 'AnnouncementUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Announcement_id_OrderByInput = TypedDict(
    '_Announcement_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Announcement_title_OrderByInput = TypedDict(
    '_Announcement_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Announcement_file_path_OrderByInput = TypedDict(
    '_Announcement_file_path_OrderByInput',
    {
        'file_path': 'SortOrder',
    },
    total=True
)

_Announcement_duration_OrderByInput = TypedDict(
    '_Announcement_duration_OrderByInput',
    {
        'duration': 'SortOrder',
    },
    total=True
)

_Announcement_file_size_OrderByInput = TypedDict(
    '_Announcement_file_size_OrderByInput',
    {
        'file_size': 'SortOrder',
    },
    total=True
)

_Announcement_is_tts_OrderByInput = TypedDict(
    '_Announcement_is_tts_OrderByInput',
    {
        'is_tts': 'SortOrder',
    },
    total=True
)

_Announcement_tts_text_OrderByInput = TypedDict(
    '_Announcement_tts_text_OrderByInput',
    {
        'tts_text': 'SortOrder',
    },
    total=True
)

_Announcement_tts_voice_OrderByInput = TypedDict(
    '_Announcement_tts_voice_OrderByInput',
    {
        'tts_voice': 'SortOrder',
    },
    total=True
)

_Announcement_is_recording_OrderByInput = TypedDict(
    '_Announcement_is_recording_OrderByInput',
    {
        'is_recording': 'SortOrder',
    },
    total=True
)

_Announcement_enabled_OrderByInput = TypedDict(
    '_Announcement_enabled_OrderByInput',
    {
        'enabled': 'SortOrder',
    },
    total=True
)

_Announcement_category_OrderByInput = TypedDict(
    '_Announcement_category_OrderByInput',
    {
        'category': 'SortOrder',
    },
    total=True
)

_Announcement_created_at_OrderByInput = TypedDict(
    '_Announcement_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Announcement_updated_at_OrderByInput = TypedDict(
    '_Announcement_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_Announcement_user_id_OrderByInput = TypedDict(
    '_Announcement_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_Announcement_RelevanceInner = TypedDict(
    '_Announcement_RelevanceInner',
    {
        'fields': 'List[AnnouncementScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Announcement_RelevanceOrderByInput = TypedDict(
    '_Announcement_RelevanceOrderByInput',
    {
        '_relevance': '_Announcement_RelevanceInner',
    },
    total=True
)

AnnouncementOrderByInput = Union[
    '_Announcement_id_OrderByInput',
    '_Announcement_title_OrderByInput',
    '_Announcement_file_path_OrderByInput',
    '_Announcement_duration_OrderByInput',
    '_Announcement_file_size_OrderByInput',
    '_Announcement_is_tts_OrderByInput',
    '_Announcement_tts_text_OrderByInput',
    '_Announcement_tts_voice_OrderByInput',
    '_Announcement_is_recording_OrderByInput',
    '_Announcement_enabled_OrderByInput',
    '_Announcement_category_OrderByInput',
    '_Announcement_created_at_OrderByInput',
    '_Announcement_updated_at_OrderByInput',
    '_Announcement_user_id_OrderByInput',
    '_Announcement_RelevanceOrderByInput',
]



# recursive Announcement types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

AnnouncementRelationFilter = TypedDict(
    'AnnouncementRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class AnnouncementListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class AnnouncementInclude(TypedDict, total=False):
    """Announcement relational arguments"""
    user: Union[bool, 'UserArgsFromAnnouncement']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncement']


    

class UserIncludeFromAnnouncement(TypedDict, total=False):
    """Relational arguments for Announcement"""
    tracks: Union[bool, 'FindManyTrackArgsFromAnnouncementRecursive1']
    schedules: Union[bool, 'FindManyScheduleArgsFromAnnouncementRecursive1']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromAnnouncementRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncementRecursive1']


class UserIncludeFromAnnouncementRecursive1(TypedDict, total=False):
    """Relational arguments for Announcement"""
    tracks: Union[bool, 'FindManyTrackArgsFromAnnouncementRecursive2']
    schedules: Union[bool, 'FindManyScheduleArgsFromAnnouncementRecursive2']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromAnnouncementRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncementRecursive2']


class UserIncludeFromAnnouncementRecursive2(TypedDict, total=False):
    """Relational arguments for Announcement"""
    tracks: Union[bool, 'FindManyTrackArgsFromAnnouncementRecursive3']
    schedules: Union[bool, 'FindManyScheduleArgsFromAnnouncementRecursive3']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromAnnouncementRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncementRecursive3']


class UserIncludeFromAnnouncementRecursive3(TypedDict, total=False):
    """Relational arguments for Announcement"""
    tracks: Union[bool, 'FindManyTrackArgsFromAnnouncementRecursive4']
    schedules: Union[bool, 'FindManyScheduleArgsFromAnnouncementRecursive4']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromAnnouncementRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncementRecursive4']


class UserIncludeFromAnnouncementRecursive4(TypedDict, total=False):
    """Relational arguments for Announcement"""

    

class UserArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    
    

class FindManyUserArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TrackIncludeFromAnnouncement(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive1']


class TrackIncludeFromAnnouncementRecursive1(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive2']


class TrackIncludeFromAnnouncementRecursive2(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive3']


class TrackIncludeFromAnnouncementRecursive3(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive4']


class TrackIncludeFromAnnouncementRecursive4(TypedDict, total=False):
    """Relational arguments for Announcement"""

    

class TrackArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'TrackIncludeFromTrackRecursive1'


class TrackArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'TrackIncludeFromTrackRecursive2'


class TrackArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'TrackIncludeFromTrackRecursive3'


class TrackArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'TrackIncludeFromTrackRecursive4'


class TrackArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    
    

class FindManyTrackArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive1'


class FindManyTrackArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive2'


class FindManyTrackArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive3'


class FindManyTrackArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive4'


class FindManyTrackArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    
    

class ScheduleIncludeFromAnnouncement(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive1']


class ScheduleIncludeFromAnnouncementRecursive1(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive2']


class ScheduleIncludeFromAnnouncementRecursive2(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive3']


class ScheduleIncludeFromAnnouncementRecursive3(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive4']


class ScheduleIncludeFromAnnouncementRecursive4(TypedDict, total=False):
    """Relational arguments for Announcement"""

    

class ScheduleArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'ScheduleIncludeFromScheduleRecursive1'


class ScheduleArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'ScheduleIncludeFromScheduleRecursive2'


class ScheduleArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'ScheduleIncludeFromScheduleRecursive3'


class ScheduleArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'ScheduleIncludeFromScheduleRecursive4'


class ScheduleArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    
    

class FindManyScheduleArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive1'


class FindManyScheduleArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive2'


class FindManyScheduleArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive3'


class FindManyScheduleArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive4'


class FindManyScheduleArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    
    

class AnnouncementIncludeFromAnnouncement(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncementRecursive1']


class AnnouncementIncludeFromAnnouncementRecursive1(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncementRecursive2']


class AnnouncementIncludeFromAnnouncementRecursive2(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncementRecursive3']


class AnnouncementIncludeFromAnnouncementRecursive3(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromAnnouncementRecursive4']


class AnnouncementIncludeFromAnnouncementRecursive4(TypedDict, total=False):
    """Relational arguments for Announcement"""

    

class AnnouncementArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class AnnouncementArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class AnnouncementArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class AnnouncementArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class AnnouncementArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    
    

class FindManyAnnouncementArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class FindManyAnnouncementArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class FindManyAnnouncementArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class FindManyAnnouncementArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class FindManyAnnouncementArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    
    

class PlayLogIncludeFromAnnouncement(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive1']
    announcement: Union[bool, 'AnnouncementArgsFromAnnouncementRecursive1']


class PlayLogIncludeFromAnnouncementRecursive1(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive2']
    announcement: Union[bool, 'AnnouncementArgsFromAnnouncementRecursive2']


class PlayLogIncludeFromAnnouncementRecursive2(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive3']
    announcement: Union[bool, 'AnnouncementArgsFromAnnouncementRecursive3']


class PlayLogIncludeFromAnnouncementRecursive3(TypedDict, total=False):
    """Relational arguments for Announcement"""
    user: Union[bool, 'UserArgsFromAnnouncementRecursive4']
    announcement: Union[bool, 'AnnouncementArgsFromAnnouncementRecursive4']


class PlayLogIncludeFromAnnouncementRecursive4(TypedDict, total=False):
    """Relational arguments for Announcement"""

    

class PlayLogArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class PlayLogArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class PlayLogArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class PlayLogArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class PlayLogArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    
    

class FindManyPlayLogArgsFromAnnouncement(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class FindManyPlayLogArgsFromAnnouncementRecursive1(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class FindManyPlayLogArgsFromAnnouncementRecursive2(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class FindManyPlayLogArgsFromAnnouncementRecursive3(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class FindManyPlayLogArgsFromAnnouncementRecursive4(TypedDict, total=False):
    """Arguments for Announcement"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    


FindManyAnnouncementArgs = FindManyAnnouncementArgsFromAnnouncement
FindFirstAnnouncementArgs = FindManyAnnouncementArgsFromAnnouncement


    

class AnnouncementWhereInput(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    duration: Union[_int, 'types.IntFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    is_tts: Union[_bool, 'types.BooleanFilter']
    tts_text: Union[None, _str, 'types.StringFilter']
    tts_voice: Union[None, _str, 'types.StringFilter']
    is_recording: Union[_bool, 'types.BooleanFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    category: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    play_logs: 'PlayLogListRelationFilter'

    # should be noted that AND and NOT should be Union['AnnouncementWhereInputRecursive1', List['AnnouncementWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['AnnouncementWhereInputRecursive1']
    OR: List['AnnouncementWhereInputRecursive1']
    NOT: List['AnnouncementWhereInputRecursive1']


class AnnouncementWhereInputRecursive1(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    duration: Union[_int, 'types.IntFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    is_tts: Union[_bool, 'types.BooleanFilter']
    tts_text: Union[None, _str, 'types.StringFilter']
    tts_voice: Union[None, _str, 'types.StringFilter']
    is_recording: Union[_bool, 'types.BooleanFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    category: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    play_logs: 'PlayLogListRelationFilter'

    # should be noted that AND and NOT should be Union['AnnouncementWhereInputRecursive2', List['AnnouncementWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['AnnouncementWhereInputRecursive2']
    OR: List['AnnouncementWhereInputRecursive2']
    NOT: List['AnnouncementWhereInputRecursive2']


class AnnouncementWhereInputRecursive2(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    duration: Union[_int, 'types.IntFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    is_tts: Union[_bool, 'types.BooleanFilter']
    tts_text: Union[None, _str, 'types.StringFilter']
    tts_voice: Union[None, _str, 'types.StringFilter']
    is_recording: Union[_bool, 'types.BooleanFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    category: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    play_logs: 'PlayLogListRelationFilter'

    # should be noted that AND and NOT should be Union['AnnouncementWhereInputRecursive3', List['AnnouncementWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['AnnouncementWhereInputRecursive3']
    OR: List['AnnouncementWhereInputRecursive3']
    NOT: List['AnnouncementWhereInputRecursive3']


class AnnouncementWhereInputRecursive3(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    duration: Union[_int, 'types.IntFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    is_tts: Union[_bool, 'types.BooleanFilter']
    tts_text: Union[None, _str, 'types.StringFilter']
    tts_voice: Union[None, _str, 'types.StringFilter']
    is_recording: Union[_bool, 'types.BooleanFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    category: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    play_logs: 'PlayLogListRelationFilter'

    # should be noted that AND and NOT should be Union['AnnouncementWhereInputRecursive4', List['AnnouncementWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['AnnouncementWhereInputRecursive4']
    OR: List['AnnouncementWhereInputRecursive4']
    NOT: List['AnnouncementWhereInputRecursive4']


class AnnouncementWhereInputRecursive4(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    file_path: Union[_str, 'types.StringFilter']
    duration: Union[_int, 'types.IntFilter']
    file_size: Union[_int, 'types.BigIntFilter']
    is_tts: Union[_bool, 'types.BooleanFilter']
    tts_text: Union[None, _str, 'types.StringFilter']
    tts_voice: Union[None, _str, 'types.StringFilter']
    is_recording: Union[_bool, 'types.BooleanFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    category: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    play_logs: 'PlayLogListRelationFilter'



# aggregate Announcement types


    

class AnnouncementScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    is_tts: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tts_text: Union[_str, 'types.StringWithAggregatesFilter']
    tts_voice: Union[_str, 'types.StringWithAggregatesFilter']
    is_recording: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AnnouncementScalarWhereWithAggregatesInputRecursive1']
    OR: List['AnnouncementScalarWhereWithAggregatesInputRecursive1']
    NOT: List['AnnouncementScalarWhereWithAggregatesInputRecursive1']


class AnnouncementScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    is_tts: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tts_text: Union[_str, 'types.StringWithAggregatesFilter']
    tts_voice: Union[_str, 'types.StringWithAggregatesFilter']
    is_recording: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AnnouncementScalarWhereWithAggregatesInputRecursive2']
    OR: List['AnnouncementScalarWhereWithAggregatesInputRecursive2']
    NOT: List['AnnouncementScalarWhereWithAggregatesInputRecursive2']


class AnnouncementScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    is_tts: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tts_text: Union[_str, 'types.StringWithAggregatesFilter']
    tts_voice: Union[_str, 'types.StringWithAggregatesFilter']
    is_recording: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AnnouncementScalarWhereWithAggregatesInputRecursive3']
    OR: List['AnnouncementScalarWhereWithAggregatesInputRecursive3']
    NOT: List['AnnouncementScalarWhereWithAggregatesInputRecursive3']


class AnnouncementScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    is_tts: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tts_text: Union[_str, 'types.StringWithAggregatesFilter']
    tts_voice: Union[_str, 'types.StringWithAggregatesFilter']
    is_recording: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AnnouncementScalarWhereWithAggregatesInputRecursive4']
    OR: List['AnnouncementScalarWhereWithAggregatesInputRecursive4']
    NOT: List['AnnouncementScalarWhereWithAggregatesInputRecursive4']


class AnnouncementScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Announcement arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    file_path: Union[_str, 'types.StringWithAggregatesFilter']
    duration: Union[_int, 'types.IntWithAggregatesFilter']
    file_size: Union[_int, 'types.BigIntWithAggregatesFilter']
    is_tts: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tts_text: Union[_str, 'types.StringWithAggregatesFilter']
    tts_voice: Union[_str, 'types.StringWithAggregatesFilter']
    is_recording: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']



class AnnouncementGroupByOutput(TypedDict, total=False):
    id: _str
    title: _str
    file_path: _str
    duration: _int
    file_size: _int
    is_tts: _bool
    tts_text: _str
    tts_voice: _str
    is_recording: _bool
    enabled: _bool
    category: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: _str
    _sum: 'AnnouncementSumAggregateOutput'
    _avg: 'AnnouncementAvgAggregateOutput'
    _min: 'AnnouncementMinAggregateOutput'
    _max: 'AnnouncementMaxAggregateOutput'
    _count: 'AnnouncementCountAggregateOutput'


class AnnouncementAvgAggregateOutput(TypedDict, total=False):
    """Announcement output for aggregating averages"""
    duration: float
    file_size: float


class AnnouncementSumAggregateOutput(TypedDict, total=False):
    """Announcement output for aggregating sums"""
    duration: _int
    file_size: _int


class AnnouncementScalarAggregateOutput(TypedDict, total=False):
    """Announcement output including scalar fields"""
    id: _str
    title: _str
    file_path: _str
    duration: _int
    file_size: _int
    is_tts: _bool
    tts_text: _str
    tts_voice: _str
    is_recording: _bool
    enabled: _bool
    category: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: _str


AnnouncementMinAggregateOutput = AnnouncementScalarAggregateOutput
AnnouncementMaxAggregateOutput = AnnouncementScalarAggregateOutput


class AnnouncementMaxAggregateInput(TypedDict, total=False):
    """Announcement input for aggregating by max"""
    id: bool
    title: bool
    file_path: bool
    duration: bool
    file_size: bool
    is_tts: bool
    tts_text: bool
    tts_voice: bool
    is_recording: bool
    enabled: bool
    category: bool
    created_at: bool
    updated_at: bool
    user_id: bool


class AnnouncementMinAggregateInput(TypedDict, total=False):
    """Announcement input for aggregating by min"""
    id: bool
    title: bool
    file_path: bool
    duration: bool
    file_size: bool
    is_tts: bool
    tts_text: bool
    tts_voice: bool
    is_recording: bool
    enabled: bool
    category: bool
    created_at: bool
    updated_at: bool
    user_id: bool


class AnnouncementNumberAggregateInput(TypedDict, total=False):
    """Announcement input for aggregating numbers"""
    duration: bool
    file_size: bool


AnnouncementAvgAggregateInput = AnnouncementNumberAggregateInput
AnnouncementSumAggregateInput = AnnouncementNumberAggregateInput


AnnouncementCountAggregateInput = TypedDict(
    'AnnouncementCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'file_path': bool,
        'duration': bool,
        'file_size': bool,
        'is_tts': bool,
        'tts_text': bool,
        'tts_voice': bool,
        'is_recording': bool,
        'enabled': bool,
        'category': bool,
        'created_at': bool,
        'updated_at': bool,
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

AnnouncementCountAggregateOutput = TypedDict(
    'AnnouncementCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'file_path': int,
        'duration': int,
        'file_size': int,
        'is_tts': int,
        'tts_text': int,
        'tts_voice': int,
        'is_recording': int,
        'enabled': int,
        'category': int,
        'created_at': int,
        'updated_at': int,
        'user_id': int,
        '_all': int,
    },
    total=False,
)


AnnouncementKeys = Literal[
    'id',
    'title',
    'file_path',
    'duration',
    'file_size',
    'is_tts',
    'tts_text',
    'tts_voice',
    'is_recording',
    'enabled',
    'category',
    'created_at',
    'updated_at',
    'user_id',
    'user',
    'play_logs',
]
AnnouncementScalarFieldKeys = Literal[
    'id',
    'title',
    'file_path',
    'duration',
    'file_size',
    'is_tts',
    'tts_text',
    'tts_voice',
    'is_recording',
    'enabled',
    'category',
    'created_at',
    'updated_at',
    'user_id',
]
AnnouncementScalarFieldKeysT = TypeVar('AnnouncementScalarFieldKeysT', bound=AnnouncementScalarFieldKeys)

AnnouncementRelationalFieldKeys = Literal[
        'user',
        'play_logs',
    ]

# PlayLog types

class PlayLogOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PlayLog create method"""
    id: _str
    status: _str
    delivered_at: Optional[datetime.datetime]
    completed_at: Optional[datetime.datetime]
    error_message: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: Optional[_str]
    user: 'UserCreateNestedWithoutRelationsInput'
    announcement_id: _str
    announcement: 'AnnouncementCreateNestedWithoutRelationsInput'


class PlayLogCreateInput(PlayLogOptionalCreateInput):
    """Required arguments to the PlayLog create method"""
    event_type: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PlayLogOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PlayLog create method, without relations"""
    id: _str
    status: _str
    delivered_at: Optional[datetime.datetime]
    completed_at: Optional[datetime.datetime]
    error_message: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: Optional[_str]
    announcement_id: _str


class PlayLogCreateWithoutRelationsInput(PlayLogOptionalCreateWithoutRelationsInput):
    """Required arguments to the PlayLog create method, without relations"""
    event_type: _str

class PlayLogConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PlayLogCreateWithoutRelationsInput'
    where: 'PlayLogWhereUniqueInput'

class PlayLogCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayLogCreateWithoutRelationsInput'
    connect: 'PlayLogWhereUniqueInput'
    connect_or_create: 'PlayLogConnectOrCreateWithoutRelationsInput'


class PlayLogCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PlayLogCreateWithoutRelationsInput', List['PlayLogCreateWithoutRelationsInput']]
    connect: Union['PlayLogWhereUniqueInput', List['PlayLogWhereUniqueInput']]
    connect_or_create: Union['PlayLogConnectOrCreateWithoutRelationsInput', List['PlayLogConnectOrCreateWithoutRelationsInput']]

_PlayLogWhereUnique_id_Input = TypedDict(
    '_PlayLogWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PlayLogWhereUniqueInput = _PlayLogWhereUnique_id_Input


class PlayLogUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    event_type: _str
    status: _str
    delivered_at: Optional[datetime.datetime]
    completed_at: Optional[datetime.datetime]
    error_message: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    announcement: 'AnnouncementUpdateOneWithoutRelationsInput'


class PlayLogUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    event_type: _str
    status: _str
    delivered_at: Optional[datetime.datetime]
    completed_at: Optional[datetime.datetime]
    error_message: Optional[_str]
    created_at: datetime.datetime
    updated_at: datetime.datetime


class PlayLogUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PlayLogCreateWithoutRelationsInput']
    connect: List['PlayLogWhereUniqueInput']
    connect_or_create: List['PlayLogConnectOrCreateWithoutRelationsInput']
    set: List['PlayLogWhereUniqueInput']
    disconnect: List['PlayLogWhereUniqueInput']
    delete: List['PlayLogWhereUniqueInput']

    # TODO
    # update: List['PlayLogUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PlayLogUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PlayLogScalarWhereInput']
    # upsert: List['PlayLogUpserteWithWhereUniqueWithoutRelationsInput']


class PlayLogUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PlayLogCreateWithoutRelationsInput'
    connect: 'PlayLogWhereUniqueInput'
    connect_or_create: 'PlayLogConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PlayLogUpdateInput'
    # upsert: 'PlayLogUpsertWithoutRelationsInput'


class PlayLogUpsertInput(TypedDict):
    create: 'PlayLogCreateInput'
    update: 'PlayLogUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PlayLog_id_OrderByInput = TypedDict(
    '_PlayLog_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PlayLog_event_type_OrderByInput = TypedDict(
    '_PlayLog_event_type_OrderByInput',
    {
        'event_type': 'SortOrder',
    },
    total=True
)

_PlayLog_status_OrderByInput = TypedDict(
    '_PlayLog_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_PlayLog_delivered_at_OrderByInput = TypedDict(
    '_PlayLog_delivered_at_OrderByInput',
    {
        'delivered_at': 'SortOrder',
    },
    total=True
)

_PlayLog_completed_at_OrderByInput = TypedDict(
    '_PlayLog_completed_at_OrderByInput',
    {
        'completed_at': 'SortOrder',
    },
    total=True
)

_PlayLog_error_message_OrderByInput = TypedDict(
    '_PlayLog_error_message_OrderByInput',
    {
        'error_message': 'SortOrder',
    },
    total=True
)

_PlayLog_created_at_OrderByInput = TypedDict(
    '_PlayLog_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_PlayLog_updated_at_OrderByInput = TypedDict(
    '_PlayLog_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_PlayLog_user_id_OrderByInput = TypedDict(
    '_PlayLog_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_PlayLog_announcement_id_OrderByInput = TypedDict(
    '_PlayLog_announcement_id_OrderByInput',
    {
        'announcement_id': 'SortOrder',
    },
    total=True
)

_PlayLog_RelevanceInner = TypedDict(
    '_PlayLog_RelevanceInner',
    {
        'fields': 'List[PlayLogScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_PlayLog_RelevanceOrderByInput = TypedDict(
    '_PlayLog_RelevanceOrderByInput',
    {
        '_relevance': '_PlayLog_RelevanceInner',
    },
    total=True
)

PlayLogOrderByInput = Union[
    '_PlayLog_id_OrderByInput',
    '_PlayLog_event_type_OrderByInput',
    '_PlayLog_status_OrderByInput',
    '_PlayLog_delivered_at_OrderByInput',
    '_PlayLog_completed_at_OrderByInput',
    '_PlayLog_error_message_OrderByInput',
    '_PlayLog_created_at_OrderByInput',
    '_PlayLog_updated_at_OrderByInput',
    '_PlayLog_user_id_OrderByInput',
    '_PlayLog_announcement_id_OrderByInput',
    '_PlayLog_RelevanceOrderByInput',
]



# recursive PlayLog types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

PlayLogRelationFilter = TypedDict(
    'PlayLogRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class PlayLogListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class PlayLogInclude(TypedDict, total=False):
    """PlayLog relational arguments"""
    user: Union[bool, 'UserArgsFromPlayLog']
    announcement: Union[bool, 'AnnouncementArgsFromPlayLog']


    

class UserIncludeFromPlayLog(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    tracks: Union[bool, 'FindManyTrackArgsFromPlayLogRecursive1']
    schedules: Union[bool, 'FindManyScheduleArgsFromPlayLogRecursive1']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromPlayLogRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromPlayLogRecursive1']


class UserIncludeFromPlayLogRecursive1(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    tracks: Union[bool, 'FindManyTrackArgsFromPlayLogRecursive2']
    schedules: Union[bool, 'FindManyScheduleArgsFromPlayLogRecursive2']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromPlayLogRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromPlayLogRecursive2']


class UserIncludeFromPlayLogRecursive2(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    tracks: Union[bool, 'FindManyTrackArgsFromPlayLogRecursive3']
    schedules: Union[bool, 'FindManyScheduleArgsFromPlayLogRecursive3']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromPlayLogRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromPlayLogRecursive3']


class UserIncludeFromPlayLogRecursive3(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    tracks: Union[bool, 'FindManyTrackArgsFromPlayLogRecursive4']
    schedules: Union[bool, 'FindManyScheduleArgsFromPlayLogRecursive4']
    announcements: Union[bool, 'FindManyAnnouncementArgsFromPlayLogRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromPlayLogRecursive4']


class UserIncludeFromPlayLogRecursive4(TypedDict, total=False):
    """Relational arguments for PlayLog"""

    

class UserArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    
    

class FindManyUserArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TrackIncludeFromPlayLog(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive1']


class TrackIncludeFromPlayLogRecursive1(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive2']


class TrackIncludeFromPlayLogRecursive2(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive3']


class TrackIncludeFromPlayLogRecursive3(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive4']


class TrackIncludeFromPlayLogRecursive4(TypedDict, total=False):
    """Relational arguments for PlayLog"""

    

class TrackArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'TrackIncludeFromTrackRecursive1'


class TrackArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'TrackIncludeFromTrackRecursive2'


class TrackArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'TrackIncludeFromTrackRecursive3'


class TrackArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'TrackIncludeFromTrackRecursive4'


class TrackArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    
    

class FindManyTrackArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive1'


class FindManyTrackArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive2'


class FindManyTrackArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive3'


class FindManyTrackArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    include: 'TrackIncludeFromTrackRecursive4'


class FindManyTrackArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['TrackOrderByInput', List['TrackOrderByInput']]
    where: 'TrackWhereInput'
    cursor: 'TrackWhereUniqueInput'
    distinct: List['TrackScalarFieldKeys']
    
    

class ScheduleIncludeFromPlayLog(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive1']


class ScheduleIncludeFromPlayLogRecursive1(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive2']


class ScheduleIncludeFromPlayLogRecursive2(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive3']


class ScheduleIncludeFromPlayLogRecursive3(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive4']


class ScheduleIncludeFromPlayLogRecursive4(TypedDict, total=False):
    """Relational arguments for PlayLog"""

    

class ScheduleArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'ScheduleIncludeFromScheduleRecursive1'


class ScheduleArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'ScheduleIncludeFromScheduleRecursive2'


class ScheduleArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'ScheduleIncludeFromScheduleRecursive3'


class ScheduleArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'ScheduleIncludeFromScheduleRecursive4'


class ScheduleArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    
    

class FindManyScheduleArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive1'


class FindManyScheduleArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive2'


class FindManyScheduleArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive3'


class FindManyScheduleArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    include: 'ScheduleIncludeFromScheduleRecursive4'


class FindManyScheduleArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['ScheduleOrderByInput', List['ScheduleOrderByInput']]
    where: 'ScheduleWhereInput'
    cursor: 'ScheduleWhereUniqueInput'
    distinct: List['ScheduleScalarFieldKeys']
    
    

class AnnouncementIncludeFromPlayLog(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive1']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromPlayLogRecursive1']


class AnnouncementIncludeFromPlayLogRecursive1(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive2']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromPlayLogRecursive2']


class AnnouncementIncludeFromPlayLogRecursive2(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive3']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromPlayLogRecursive3']


class AnnouncementIncludeFromPlayLogRecursive3(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive4']
    play_logs: Union[bool, 'FindManyPlayLogArgsFromPlayLogRecursive4']


class AnnouncementIncludeFromPlayLogRecursive4(TypedDict, total=False):
    """Relational arguments for PlayLog"""

    

class AnnouncementArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class AnnouncementArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class AnnouncementArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class AnnouncementArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class AnnouncementArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    
    

class FindManyAnnouncementArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive1'


class FindManyAnnouncementArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive2'


class FindManyAnnouncementArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive3'


class FindManyAnnouncementArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    include: 'AnnouncementIncludeFromAnnouncementRecursive4'


class FindManyAnnouncementArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['AnnouncementOrderByInput', List['AnnouncementOrderByInput']]
    where: 'AnnouncementWhereInput'
    cursor: 'AnnouncementWhereUniqueInput'
    distinct: List['AnnouncementScalarFieldKeys']
    
    

class PlayLogIncludeFromPlayLog(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive1']
    announcement: Union[bool, 'AnnouncementArgsFromPlayLogRecursive1']


class PlayLogIncludeFromPlayLogRecursive1(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive2']
    announcement: Union[bool, 'AnnouncementArgsFromPlayLogRecursive2']


class PlayLogIncludeFromPlayLogRecursive2(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive3']
    announcement: Union[bool, 'AnnouncementArgsFromPlayLogRecursive3']


class PlayLogIncludeFromPlayLogRecursive3(TypedDict, total=False):
    """Relational arguments for PlayLog"""
    user: Union[bool, 'UserArgsFromPlayLogRecursive4']
    announcement: Union[bool, 'AnnouncementArgsFromPlayLogRecursive4']


class PlayLogIncludeFromPlayLogRecursive4(TypedDict, total=False):
    """Relational arguments for PlayLog"""

    

class PlayLogArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class PlayLogArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class PlayLogArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class PlayLogArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class PlayLogArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    
    

class FindManyPlayLogArgsFromPlayLog(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive1'


class FindManyPlayLogArgsFromPlayLogRecursive1(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive2'


class FindManyPlayLogArgsFromPlayLogRecursive2(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive3'


class FindManyPlayLogArgsFromPlayLogRecursive3(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    include: 'PlayLogIncludeFromPlayLogRecursive4'


class FindManyPlayLogArgsFromPlayLogRecursive4(TypedDict, total=False):
    """Arguments for PlayLog"""
    take: int
    skip: int
    order_by: Union['PlayLogOrderByInput', List['PlayLogOrderByInput']]
    where: 'PlayLogWhereInput'
    cursor: 'PlayLogWhereUniqueInput'
    distinct: List['PlayLogScalarFieldKeys']
    


FindManyPlayLogArgs = FindManyPlayLogArgsFromPlayLog
FindFirstPlayLogArgs = FindManyPlayLogArgsFromPlayLog


    

class PlayLogWhereInput(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    event_type: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    delivered_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    completed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    error_message: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    announcement_id: Union[_str, 'types.StringFilter']
    announcement: 'AnnouncementRelationFilter'

    # should be noted that AND and NOT should be Union['PlayLogWhereInputRecursive1', List['PlayLogWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['PlayLogWhereInputRecursive1']
    OR: List['PlayLogWhereInputRecursive1']
    NOT: List['PlayLogWhereInputRecursive1']


class PlayLogWhereInputRecursive1(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    event_type: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    delivered_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    completed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    error_message: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    announcement_id: Union[_str, 'types.StringFilter']
    announcement: 'AnnouncementRelationFilter'

    # should be noted that AND and NOT should be Union['PlayLogWhereInputRecursive2', List['PlayLogWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['PlayLogWhereInputRecursive2']
    OR: List['PlayLogWhereInputRecursive2']
    NOT: List['PlayLogWhereInputRecursive2']


class PlayLogWhereInputRecursive2(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    event_type: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    delivered_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    completed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    error_message: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    announcement_id: Union[_str, 'types.StringFilter']
    announcement: 'AnnouncementRelationFilter'

    # should be noted that AND and NOT should be Union['PlayLogWhereInputRecursive3', List['PlayLogWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['PlayLogWhereInputRecursive3']
    OR: List['PlayLogWhereInputRecursive3']
    NOT: List['PlayLogWhereInputRecursive3']


class PlayLogWhereInputRecursive3(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    event_type: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    delivered_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    completed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    error_message: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    announcement_id: Union[_str, 'types.StringFilter']
    announcement: 'AnnouncementRelationFilter'

    # should be noted that AND and NOT should be Union['PlayLogWhereInputRecursive4', List['PlayLogWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['PlayLogWhereInputRecursive4']
    OR: List['PlayLogWhereInputRecursive4']
    NOT: List['PlayLogWhereInputRecursive4']


class PlayLogWhereInputRecursive4(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    event_type: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    delivered_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    completed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    error_message: Union[None, _str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    user_id: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'
    announcement_id: Union[_str, 'types.StringFilter']
    announcement: 'AnnouncementRelationFilter'



# aggregate PlayLog types


    

class PlayLogScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    event_type: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    delivered_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    error_message: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    announcement_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlayLogScalarWhereWithAggregatesInputRecursive1']
    OR: List['PlayLogScalarWhereWithAggregatesInputRecursive1']
    NOT: List['PlayLogScalarWhereWithAggregatesInputRecursive1']


class PlayLogScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    event_type: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    delivered_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    error_message: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    announcement_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlayLogScalarWhereWithAggregatesInputRecursive2']
    OR: List['PlayLogScalarWhereWithAggregatesInputRecursive2']
    NOT: List['PlayLogScalarWhereWithAggregatesInputRecursive2']


class PlayLogScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    event_type: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    delivered_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    error_message: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    announcement_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlayLogScalarWhereWithAggregatesInputRecursive3']
    OR: List['PlayLogScalarWhereWithAggregatesInputRecursive3']
    NOT: List['PlayLogScalarWhereWithAggregatesInputRecursive3']


class PlayLogScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    event_type: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    delivered_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    error_message: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    announcement_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlayLogScalarWhereWithAggregatesInputRecursive4']
    OR: List['PlayLogScalarWhereWithAggregatesInputRecursive4']
    NOT: List['PlayLogScalarWhereWithAggregatesInputRecursive4']


class PlayLogScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """PlayLog arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    event_type: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    delivered_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    error_message: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']
    announcement_id: Union[_str, 'types.StringWithAggregatesFilter']



class PlayLogGroupByOutput(TypedDict, total=False):
    id: _str
    event_type: _str
    status: _str
    delivered_at: datetime.datetime
    completed_at: datetime.datetime
    error_message: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: _str
    announcement_id: _str
    _sum: 'PlayLogSumAggregateOutput'
    _avg: 'PlayLogAvgAggregateOutput'
    _min: 'PlayLogMinAggregateOutput'
    _max: 'PlayLogMaxAggregateOutput'
    _count: 'PlayLogCountAggregateOutput'


class PlayLogAvgAggregateOutput(TypedDict, total=False):
    """PlayLog output for aggregating averages"""


class PlayLogSumAggregateOutput(TypedDict, total=False):
    """PlayLog output for aggregating sums"""


class PlayLogScalarAggregateOutput(TypedDict, total=False):
    """PlayLog output including scalar fields"""
    id: _str
    event_type: _str
    status: _str
    delivered_at: datetime.datetime
    completed_at: datetime.datetime
    error_message: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    user_id: _str
    announcement_id: _str


PlayLogMinAggregateOutput = PlayLogScalarAggregateOutput
PlayLogMaxAggregateOutput = PlayLogScalarAggregateOutput


class PlayLogMaxAggregateInput(TypedDict, total=False):
    """PlayLog input for aggregating by max"""
    id: bool
    event_type: bool
    status: bool
    delivered_at: bool
    completed_at: bool
    error_message: bool
    created_at: bool
    updated_at: bool
    user_id: bool
    announcement_id: bool


class PlayLogMinAggregateInput(TypedDict, total=False):
    """PlayLog input for aggregating by min"""
    id: bool
    event_type: bool
    status: bool
    delivered_at: bool
    completed_at: bool
    error_message: bool
    created_at: bool
    updated_at: bool
    user_id: bool
    announcement_id: bool


class PlayLogNumberAggregateInput(TypedDict, total=False):
    """PlayLog input for aggregating numbers"""


PlayLogAvgAggregateInput = PlayLogNumberAggregateInput
PlayLogSumAggregateInput = PlayLogNumberAggregateInput


PlayLogCountAggregateInput = TypedDict(
    'PlayLogCountAggregateInput',
    {
        'id': bool,
        'event_type': bool,
        'status': bool,
        'delivered_at': bool,
        'completed_at': bool,
        'error_message': bool,
        'created_at': bool,
        'updated_at': bool,
        'user_id': bool,
        'announcement_id': bool,
        '_all': bool,
    },
    total=False,
)

PlayLogCountAggregateOutput = TypedDict(
    'PlayLogCountAggregateOutput',
    {
        'id': int,
        'event_type': int,
        'status': int,
        'delivered_at': int,
        'completed_at': int,
        'error_message': int,
        'created_at': int,
        'updated_at': int,
        'user_id': int,
        'announcement_id': int,
        '_all': int,
    },
    total=False,
)


PlayLogKeys = Literal[
    'id',
    'event_type',
    'status',
    'delivered_at',
    'completed_at',
    'error_message',
    'created_at',
    'updated_at',
    'user_id',
    'user',
    'announcement_id',
    'announcement',
]
PlayLogScalarFieldKeys = Literal[
    'id',
    'event_type',
    'status',
    'delivered_at',
    'completed_at',
    'error_message',
    'created_at',
    'updated_at',
    'user_id',
    'announcement_id',
]
PlayLogScalarFieldKeysT = TypeVar('PlayLogScalarFieldKeysT', bound=PlayLogScalarFieldKeys)

PlayLogRelationalFieldKeys = Literal[
        'user',
        'announcement',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields
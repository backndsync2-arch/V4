=============================================================================
CURSOR AI MASTER PROMPT - Copy and paste this entire prompt into Cursor AI
=============================================================================

I need you to build a complete Django REST API backend for sync2gear, a music and announcements management system for businesses. This is a production-ready system that requires zero human input after you generate it.

=============================================================================
PROJECT OVERVIEW
=============================================================================

sync2gear handles:
- Music library management with folders and metadata
- Announcement creation (TTS, upload, recording)
- Scheduling system (interval and timeline-based)
- Multi-zone playback control
- Real-time device synchronization via WebSocket
- Admin dashboard for client management
- Role-based permissions (client, staff, admin)
- Continuous playback (music never stops)

=============================================================================
TECHNOLOGY STACK
=============================================================================

Core:
- Django 5.0+ with Django REST Framework 3.14+
- PostgreSQL 15+ (primary database)
- Redis 7+ (caching + WebSocket)
- Django Channels 4.0+ (WebSocket)
- Celery 5.3+ (background tasks)
- djangorestframework-simplejwt (JWT auth)

Storage & Services:
- AWS S3 (media storage)
- Google Cloud Text-to-Speech
- mutagen (audio metadata)
- Pillow (image processing)

Production:
- Gunicorn (WSGI server)
- Daphne (ASGI server)
- Docker + docker-compose
- nginx (reverse proxy)

=============================================================================
CRITICAL REQUIREMENTS
=============================================================================

1. UUID primary keys for all models (not integer IDs)
2. Multi-tenancy with client-based data isolation
3. JWT authentication with refresh token rotation
4. Role-based permissions (client, staff, admin)
5. AWS S3 for all media files (music, announcements, images)
6. Celery for async tasks (metadata extraction, TTS, scheduling)
7. WebSocket for real-time playback updates
8. Continuous playback - music NEVER stops, loops infinitely
9. Announcement interruption with automatic music resume
10. Interval and timeline scheduling modes
11. PostgreSQL with proper indexes and constraints
12. Redis for channel layers and caching
13. Comprehensive error handling with meaningful messages
14. API documentation with drf-spectacular (Swagger UI)
15. Docker configuration for easy deployment
16. Environment variables for all configuration
17. CORS configured for frontend communication
18. Pagination on all list endpoints
19. Filtering by client (multi-tenancy)
20. Comprehensive logging throughout

=============================================================================
PHASE-BY-PHASE IMPLEMENTATION
=============================================================================

Generate code for each phase systematically. After each phase, I'll test before proceeding.

-----------------------------------------------------------------------------
PHASE 1: PROJECT INITIALIZATION
-----------------------------------------------------------------------------

1. Create Django project structure:
   - Project name: sync2gear_backend
   - Config folder: config/
   - Apps folder: apps/
   - Apps: authentication, music, announcements, scheduler, zones, playback, admin_panel, common

2. Create requirements.txt with all dependencies:
   Django==5.0.1
   djangorestframework==3.14.0
   djangorestframework-simplejwt==5.3.1
   django-cors-headers==4.3.1
   django-environ==0.11.2
   django-storages==1.14.2
   channels==4.0.0
   channels-redis==4.1.0
   daphne==4.0.0
   psycopg2-binary==2.9.9
   celery==5.3.4
   redis==5.0.1
   boto3==1.34.18
   mutagen==1.47.0
   Pillow==10.2.0
   google-cloud-texttospeech==2.16.0
   gunicorn==21.2.0
   python-dotenv==1.0.0
   drf-spectacular==0.27.1

3. Create .env.example with all variables:
   SECRET_KEY, DEBUG, ALLOWED_HOSTS, DATABASE_URL, REDIS_HOST, AWS credentials, CORS_ALLOWED_ORIGINS, etc.

-----------------------------------------------------------------------------
PHASE 2: BASE CONFIGURATION
-----------------------------------------------------------------------------

Configure settings in config/settings/:

1. base.py - Base settings:
   - INSTALLED_APPS: all apps + rest_framework + corsheaders + channels + drf_spectacular
   - MIDDLEWARE: cors, auth, security
   - REST_FRAMEWORK: JWT auth, pagination, default permissions
   - SIMPLE_JWT: 1-hour access, 7-day refresh, rotation
   - DATABASES: PostgreSQL via DATABASE_URL
   - CHANNEL_LAYERS: Redis
   - CELERY: Redis broker, result backend
   - AUTH_USER_MODEL = 'authentication.User'
   - Comprehensive logging

2. development.py - Dev overrides:
   - DEBUG=True
   - Local file storage
   - Detailed logging

3. production.py - Production settings:
   - DEBUG=False
   - AWS S3 storage
   - Security settings
   - Sentry (commented out)

4. config/urls.py - URL routing:
   /api/auth/ -> authentication
   /api/music/ -> music
   /api/announcements/ -> announcements
   /api/schedules/ -> scheduler
   /api/zones/ -> zones
   /api/devices/ -> zones (devices)
   /api/playback/ -> playback
   /api/admin/ -> admin_panel
   /api/schema/ -> drf-spectacular
   /api/docs/ -> Swagger UI
   /api/redoc/ -> ReDoc

5. config/asgi.py - ASGI for WebSocket:
   ProtocolTypeRouter with http and websocket
   AuthMiddlewareStack
   URLRouter for websocket patterns

6. config/celery.py - Celery config:
   Celery app setup
   Beat schedule (check_schedules every minute)
   Auto-discover tasks

-----------------------------------------------------------------------------
PHASE 3: DATABASE MODELS
-----------------------------------------------------------------------------

Create all models with UUID primary keys, proper relationships, and Meta classes:

1. common/models.py:
   - TimestampedModel (abstract): created_at, updated_at

2. authentication/models.py:
   - Client: id(UUID), name, email, subscription_tier, subscription_status, max_devices, max_storage_gb
   - User (AbstractBaseUser, PermissionsMixin): id(UUID), email(unique), name, client(FK), role(choices), avatar, timezone, is_active

3. music/models.py:
   - Folder: id(UUID), name, type(music/announcement), client(FK), created_by(FK), cover_image
   - MusicFile: id(UUID), file, filename, file_size, title, artist, album, genre, year, duration, cover_art, folder(FK), client(FK), order

4. announcements/models.py:
   - Announcement: id(UUID), title, file, duration, file_size, is_tts, tts_text, tts_voice, is_recording, folder(FK), client(FK)

5. scheduler/models.py:
   - Schedule: id(UUID), name, type(music/announcement), mode(interval/timeline), interval_minutes, start_time, end_time, days_of_week(ArrayField), zones(M2M), priority, is_active, client(FK)

6. zones/models.py:
   - Zone: id(UUID), name, description, default_volume, client(FK), is_active
   - Device: id(UUID), name, device_type, device_id(unique), ip_address, last_seen, is_online, volume, zone(FK), client(FK)

7. playback/models.py:
   - PlaybackState: id(UUID), zone(OneToOne), current_track(FK), queue(ArrayField of UUIDs), queue_position, is_playing, position, volume, current_playlists(ArrayField), shuffle

Include __str__ methods, proper Meta classes with db_table and ordering.

-----------------------------------------------------------------------------
PHASE 4: SERIALIZERS
-----------------------------------------------------------------------------

Create DRF serializers for all models:

1. authentication/serializers.py:
   - ClientSerializer
   - UserSerializer (exclude password)
   - UserCreateSerializer (password write-only)
   - LoginSerializer
   - SignUpSerializer
   - PasswordChangeSerializer

2. music/serializers.py:
   - FolderSerializer
   - MusicFileSerializer (include URLs)
   - MusicFileCreateSerializer
   - MusicFileUpdateSerializer

3. announcements/serializers.py:
   - AnnouncementSerializer
   - TTSCreateSerializer
   - AnnouncementUploadSerializer

4. scheduler/serializers.py:
   - ScheduleSerializer (nested zone data)
   - ScheduleCreateSerializer

5. zones/serializers.py:
   - ZoneSerializer (include device count)
   - DeviceSerializer

6. playback/serializers.py:
   - PlaybackStateSerializer (include current track details)

All with proper validation, read_only_fields, SerializerMethodFields.

-----------------------------------------------------------------------------
PHASE 5: PERMISSIONS
-----------------------------------------------------------------------------

Create custom permissions in common/permissions.py:

- IsClientUser: user.role == 'client'
- IsStaffOrAdmin: user.role in ['staff', 'admin']
- IsAdmin: user.role == 'admin'
- IsOwnerOrReadOnly: Safe methods allow all, write checks obj.client == user.client
- IsSameClient: obj.client == user.client

-----------------------------------------------------------------------------
PHASE 6: VIEWS & VIEWSETS
-----------------------------------------------------------------------------

Implement all API views:

1. authentication/views.py:
   - SignUpView: Create user + client, return tokens
   - LoginView: JWT auth, return user + tokens
   - LogoutView: Blacklist refresh token
   - CurrentUserView: GET/PATCH current user
   - ChangePasswordView: Update password
   - PasswordResetRequestView: Send reset email
   - PasswordResetConfirmView: Reset with token

2. music/views.py:
   - FolderViewSet: CRUD, filter by client
   - MusicFileViewSet: CRUD, filter by client and folder
   - MusicUploadView: Handle upload, trigger metadata extraction
   - BatchUploadView: Multiple files
   - CoverArtUploadView: Upload cover
   - ReorderTracksView: Update track order
   - MusicSearchView: Search by title/artist/album

3. announcements/views.py:
   - AnnouncementViewSet: CRUD, filter by client
   - TTSGenerateView: Queue TTS task
   - AnnouncementUploadView: Upload audio
   - InstantPlayView: Trigger instant playback

4. scheduler/views.py:
   - ScheduleViewSet: CRUD, filter by client
   - ToggleScheduleView: Activate/deactivate

5. zones/views.py:
   - ZoneViewSet: CRUD, filter by client
   - DeviceViewSet: CRUD, filter by client/zone
   - DeviceRegisterView: Register new device
   - DeviceVolumeView: Set volume

6. playback/views.py:
   - PlaybackStateView: Get state for zone
   - PlayView: Start playback, build queue
   - PauseView: Pause
   - ResumeView: Resume
   - NextTrackView: Next track
   - PreviousTrackView: Previous track
   - VolumeView: Set volume
   - SeekView: Seek position

7. admin_panel/views.py:
   - ClientViewSet: Admin only
   - UserManagementViewSet: Admin only
   - SystemStatsView: System stats

All with proper permissions, error handling, logging, transactions where needed.

-----------------------------------------------------------------------------
PHASE 7: PLAYBACK ENGINE
-----------------------------------------------------------------------------

Create apps/playback/engine.py with PlaybackEngine class:

Methods:
- start_playlist(zone_id, playlist_ids, shuffle): Build queue, set first track, broadcast
- build_queue(playlist_ids, shuffle): Get all tracks from playlists, order, shuffle
- shuffle_queue(track_ids): Random shuffle
- next_track(zone_id): Increment position, loop at end (continuous playback), broadcast
- previous_track(zone_id): Decrement or restart, broadcast
- pause(zone_id): Set is_playing=False, broadcast
- resume(zone_id): Set is_playing=True, broadcast
- set_volume(zone_id, volume): Update volume, broadcast
- seek(zone_id, position): Update position, broadcast
- handle_announcement(zone_id, announcement_id): Save state, play announcement, resume
- broadcast_state(zone_id): Send via WebSocket to zone group
- update_state(zone_id, **kwargs): Update and save state

Use select_for_update() for state modifications.
Include comprehensive error handling and logging.

-----------------------------------------------------------------------------
PHASE 8: WEBSOCKET CONSUMERS
-----------------------------------------------------------------------------

1. apps/playback/consumers.py:

PlaybackConsumer(AsyncWebsocketConsumer):
- connect(): Authenticate, join zone group, send current state
- disconnect(): Leave group
- receive(data): Handle commands (play, pause, next, etc.)
- playback_update(event): Broadcast to client
- Helper: get_playback_state() with @database_sync_to_async
- Helper: authenticate_token() to verify JWT

EventsConsumer: For global events (device status, schedules, notifications)

2. apps/playback/routing.py:
websocket_urlpatterns = [
    path('ws/playback/<uuid:zone_id>/', PlaybackConsumer.as_asgi()),
    path('ws/events/', EventsConsumer.as_asgi()),
]

-----------------------------------------------------------------------------
PHASE 9: CELERY TASKS
-----------------------------------------------------------------------------

1. apps/music/tasks.py:
   @shared_task extract_metadata(music_file_id): Use mutagen, extract duration, title, artist, album, cover art
   @shared_task generate_waveform(music_file_id): Optional

2. apps/announcements/tasks.py:
   @shared_task generate_tts(announcement_id): Google Cloud TTS, save MP3, calculate duration
   @shared_task process_recording(announcement_id): Process uploaded recording

3. apps/scheduler/tasks.py:
   @shared_task check_schedules(): Run every minute, check all active schedules, execute if due
   @shared_task execute_schedule(schedule_id): Execute individual schedule (play music/announcement)

4. apps/authentication/tasks.py:
   @shared_task cleanup_expired_sessions(): Daily cleanup
   @shared_task send_password_reset_email(user_id, token): Send reset email

All with retry logic, error handling, logging.

-----------------------------------------------------------------------------
PHASE 10: URL ROUTING
-----------------------------------------------------------------------------

Create urls.py for each app with proper routing:
- Use DefaultRouter for ViewSets
- Individual paths for APIViews
- Include app_name for namespacing

-----------------------------------------------------------------------------
PHASE 11: API DOCUMENTATION
-----------------------------------------------------------------------------

Configure drf-spectacular:
1. Add to INSTALLED_APPS
2. Set DEFAULT_SCHEMA_CLASS in REST_FRAMEWORK
3. Configure SPECTACULAR_SETTINGS
4. Add schema URLs: /api/schema/, /api/docs/, /api/redoc/
5. Add @extend_schema decorators to all views with examples

-----------------------------------------------------------------------------
PHASE 12: DOCKER CONFIGURATION
-----------------------------------------------------------------------------

1. Dockerfile:
   - FROM python:3.11-slim
   - Install PostgreSQL client, dependencies
   - Copy requirements, install packages
   - Copy code
   - Collect static
   - CMD gunicorn

2. docker-compose.yml:
   Services:
   - db (PostgreSQL 15)
   - redis (Redis 7)
   - web (Django with gunicorn)
   - websocket (Daphne ASGI server)
   - celery (worker)
   - celery-beat (scheduler)
   - nginx (reverse proxy, optional)
   
   Volumes for postgres_data, static, media

3. .dockerignore:
   __pycache__, *.pyc, venv/, .env, .git

-----------------------------------------------------------------------------
PHASE 13: DEPLOYMENT SCRIPTS
-----------------------------------------------------------------------------

Create scripts/:
- migrate.sh: Run migrations and collectstatic
- deploy.sh: Pull, rebuild, migrate, restart
- backup.sh: Backup PostgreSQL database
- create_superuser.sh: Create admin user
- logs.sh: View docker logs

Make executable: chmod +x scripts/*.sh

-----------------------------------------------------------------------------
PHASE 14: TESTING
-----------------------------------------------------------------------------

Create comprehensive tests for all apps:
- Model tests
- Serializer tests
- View tests (all endpoints)
- Permission tests
- WebSocket tests
- Task tests

Use pytest-django, factory_boy for fixtures.
Aim for >80% coverage.

=============================================================================
IMPLEMENTATION NOTES
=============================================================================

1. Use environment variables for ALL sensitive data
2. Include comprehensive docstrings in all classes/methods
3. Add logging throughout (info, warning, error levels)
4. Use database transactions for critical operations
5. Implement proper error handling with meaningful messages
6. Filter ALL queries by client for multi-tenancy
7. Use select_related and prefetch_related for optimization
8. Add database indexes on frequently queried fields
9. Validate all user inputs
10. Return consistent JSON responses
11. Include CORS headers for frontend
12. Add rate limiting (optional: django-ratelimit)
13. Use atomic transactions where needed
14. Add health check endpoints
15. Configure proper logging to files and console

=============================================================================
DELIVERABLES
=============================================================================

After completion, I should have:

✓ Complete Django project structure
✓ All models with migrations
✓ All serializers and permissions
✓ All views and viewsets
✓ Playback engine with continuous play
✓ WebSocket consumers for real-time updates
✓ All Celery tasks
✓ Complete URL routing
✓ API documentation (Swagger UI)
✓ Docker configuration
✓ Deployment scripts
✓ Comprehensive tests
✓ README with setup instructions

The backend should be production-ready and able to:
- Handle user authentication with JWT
- Upload and manage music files with metadata
- Generate TTS announcements
- Execute schedules automatically
- Stream real-time playback updates via WebSocket
- Support continuous playback that never stops
- Handle announcement interruptions
- Manage multiple clients and zones
- Provide admin dashboard with stats

=============================================================================
EXECUTION INSTRUCTIONS
=============================================================================

1. Generate code for Phase 1 first
2. Wait for my confirmation before proceeding to Phase 2
3. Continue through all phases systematically
4. After each phase, I'll run migrations and test
5. Fix any issues before moving to next phase
6. Generate complete, production-ready code
7. Include comments and docstrings
8. Follow Django/DRF best practices
9. Use type hints where appropriate
10. Make code readable and maintainable

START WITH PHASE 1: PROJECT INITIALIZATION

Generate the complete project structure and requirements.txt file.

=============================================================================

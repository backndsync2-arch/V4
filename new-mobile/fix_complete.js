const fs = require('fs');
let c = fs.readFileSync('lib/main.dart', 'utf8');
const lines = c.split('\n');
let n = 0;

function rep(desc, a, b) {
  if (c.includes(a)) { c = c.replace(a, b); n++; console.log('✓ ' + desc); }
  else console.log('✗ SKIP: ' + desc);
}

// ═══════════════════════════════════════════════════════════
// FIX 1: Add _isToggling guard + proper play/pause/resume to DashboardPage state
// ═══════════════════════════════════════════════════════════
rep('Add _isToggling state variable',
  "  // Announcement Logic\r\n  Timer? _announcementTimer;\r\n  Timer? _playbackStateTimer;\r\n  Timer? _countdownTimer;\r\n  int _nextAnnouncementIndex = 0;",
  "  // Playback flow guard\r\n  bool _isToggling = false;\r\n  List<Map<String,String>> _currentPlaylist = [];\r\n\r\n  // Announcement Logic\r\n  Timer? _announcementTimer;\r\n  Timer? _playbackStateTimer;\r\n  Timer? _countdownTimer;\r\n  int _nextAnnouncementIndex = 0;"
);

// ═══════════════════════════════════════════════════════════
// FIX 2: Replace _togglePlayback with proper play/pause/resume logic
// ═══════════════════════════════════════════════════════════
rep('Fix _togglePlayback: proper play/pause/resume (no rebuild on resume)',
  "  Future<void> _togglePlayback() async {\r\n    final pm = context.read<PlayerModel>();\r\n    final isPlaying = pm.player.playing || (_playbackState?['is_playing'] == true);\r\n    if (!isPlaying && _selectedMusicIds.isEmpty) {\r\n      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Please select at least one music track')));\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (isPlaying) {\r\n        await pm.pause();\r\n        _announcementTimer?.cancel();\r\n        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Playback paused (local)')));\r\n      } else {\r\n        // Get authentication token to append to URLs\r\n        final token = await getAccessToken();\r\n\r\n        final items = _allMusic.where((m) => _selectedMusicIds.contains((m['id'] ?? m['file_id'] ?? m['music_file_id'] ?? '').toString()))\r\n          .map((m) {\r\n            String url = (m['stream_url'] ?? m['file_url'] ?? m['url'] ?? '').toString();\r\n            // Don't add token to URL - playUrls() will handle auth via headers\r\n            return {\r\n              'url': url,\r\n              'title': (m['name'] ?? m['title'] ?? 'Unknown').toString(),\r\n            };\r\n          }).where((e) => (e['url'] ?? '').isNotEmpty).toList();\r\n        if (items.isEmpty) {\r\n          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Selected tracks have no URLs')));\r\n          return;\r\n        }\r\n\r\n        print('Starting playback with ${items.length} tracks');\r\n        if (items.isNotEmpty) {\r\n          print('First track URL: ${items.first['url']}');\r\n        }\r\n\r\n        try {\r\n          await pm.playUrls(items);\r\n          // Enable continuous looping - set to LoopMode.all for continuous playback\r\n          await pm.setLoopMode(LoopMode.all);\r\n\r\n          // Always start announcement loop - player may still be buffering\r\n          _playbackStartTime = DateTime.now();\r\n          _startAnnouncementLoop();\r\n          if (mounted) setState(() => _playbackState = {'is_playing': true});\r\n          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Playback started'), duration: Duration(seconds: 2)));\r\n          // Log player state after delay\r\n          await Future.delayed(const Duration(milliseconds: 1500));\r\n          print('Player state check: ${pm.player.playing}, ${pm.player.playerState.processingState}');\r\n        } catch (e) {\r\n          print('Error starting playback: $e');\r\n          ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed to start playback: $e')));\r\n        }\r\n      }\r\n      // Refresh state\r\n      await Future.delayed(const Duration(seconds: 1));\r\n      await _loadPlaybackState();\r\n    } catch (e, stackTrace) {\r\n      print('Playback error: $e');\r\n      print('Stack trace: $stackTrace');\r\n      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Action failed: $e')));\r\n    }\r\n  }",
  "  Future<void> _togglePlayback() async {\r\n    if (_isToggling) return;\r\n    _isToggling = true;\r\n    try {\r\n      final pm = context.read<PlayerModel>();\r\n      final actuallyPlaying = pm.player.playing;\r\n      final hasPlaylist = pm.player.sequence != null && (pm.player.sequence?.isNotEmpty ?? false);\r\n\r\n      if (actuallyPlaying) {\r\n        // ── PAUSE ──\r\n        await pm.pause();\r\n        _announcementTimer?.cancel();\r\n        _countdownTimer?.cancel();\r\n        if (mounted) setState(() => _playbackState = {'is_playing': false});\r\n        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Paused'), duration: Duration(seconds: 1)));\r\n      } else if (hasPlaylist && _currentPlaylist.isNotEmpty) {\r\n        // ── RESUME (already has playlist) ──\r\n        await pm.player.play();\r\n        await pm.setLoopMode(LoopMode.all);\r\n        _playbackStartTime ??= DateTime.now();\r\n        _startAnnouncementLoop();\r\n        if (mounted) setState(() => _playbackState = {'is_playing': true});\r\n        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Resumed'), duration: Duration(seconds: 1)));\r\n      } else {\r\n        // ── FRESH START ──\r\n        if (_selectedMusicIds.isEmpty) {\r\n          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Please select at least one music track')));\r\n          return;\r\n        }\r\n        final items = _allMusic.where((m) => _selectedMusicIds.contains((m['id'] ?? m['file_id'] ?? m['music_file_id'] ?? '').toString()))\r\n          .map((m) => {'url': (m['stream_url'] ?? m['file_url'] ?? m['url'] ?? '').toString(), 'title': (m['name'] ?? m['title'] ?? 'Unknown').toString()})\r\n          .where((e) => (e['url'] ?? '').isNotEmpty).toList();\r\n        if (items.isEmpty) {\r\n          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Selected tracks have no streamable URLs')));\r\n          return;\r\n        }\r\n        try {\r\n          _currentPlaylist = List<Map<String,String>>.from(items);\r\n          await pm.playUrls(items);\r\n          await pm.setLoopMode(LoopMode.all);\r\n          _playbackStartTime = DateTime.now();\r\n          _startAnnouncementLoop();\r\n          if (mounted) setState(() => _playbackState = {'is_playing': true});\r\n          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Playback started ✓'), duration: Duration(seconds: 2)));\r\n        } catch (e) {\r\n          _currentPlaylist = [];\r\n          ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e')));\r\n        }\r\n      }\r\n    } finally {\r\n      _isToggling = false;\r\n    }\r\n  }"
);

// ═══════════════════════════════════════════════════════════
// FIX 3: Stop button also clears playlist
// ═══════════════════════════════════════════════════════════
rep('Fix Stop button to clear playlist too',
  "              onPressed: () {\r\n                                _announcementTimer?.cancel();\r\n                                _countdownTimer?.cancel();\r\n                                setState(() => _playbackState = {'is_playing': false});\r\n                                context.read<PlayerModel>().stop();\r\n                              },",
  "              onPressed: () {\r\n                                _announcementTimer?.cancel();\r\n                                _countdownTimer?.cancel();\r\n                                _currentPlaylist = [];\r\n                                _isPlayingAnnouncement = false;\r\n                                setState(() => _playbackState = {'is_playing': false});\r\n                                context.read<PlayerModel>().stop();\r\n                              },"
);

// ═══════════════════════════════════════════════════════════
// FIX 4: Guard _playNextAnnouncement with _isPlayingAnnouncement
// Also fix: after announcement, if player stopped/completed → restart playlist
// ═══════════════════════════════════════════════════════════
rep('Guard _playNextAnnouncement against concurrent calls + fix music restore',
  "  Future<void> _playNextAnnouncement() async {\r\n    final zm = context.read<ZoneModel>();\r\n    final zoneId = zm.selectedZoneId ?? _selectedZoneId;\r\n    if (zoneId == null) return;",
  "  Future<void> _playNextAnnouncement() async {\r\n    // Guard: don't start if already playing an announcement or playback stopped\r\n    if (_isPlayingAnnouncement) { print('Ann: already playing, skipping'); return; }\r\n    final pm = context.read<PlayerModel>();\r\n    // Don't interrupt if music is not loaded at all\r\n    final zm = context.read<ZoneModel>();\r\n    final zoneId = zm.selectedZoneId ?? _selectedZoneId;\r\n    if (zoneId == null) return;"
);

// Fix music restoration after announcement to handle completed playlist
rep('Fix music restore after announcement: restart if completed',
  "        // Music kept playing - stop annPlayer and restore volume\r\n        await pm.annPlayer.stop();\r\n        if (!pm.player.playing && _wasPlayingBeforeAnnouncement) await pm.player.play();",
  "        // Stop announcement player and restore music\r\n        await pm.annPlayer.stop();\r\n        // Restore music: if not playing, try to resume\r\n        if (!pm.player.playing && _wasPlayingBeforeAnnouncement) {\r\n          try {\r\n            final state = pm.player.processingState;\r\n            if (state == ProcessingState.completed || state == ProcessingState.idle) {\r\n              // Playlist ended or was cleared → restart from beginning\r\n              if (_currentPlaylist.isNotEmpty) {\r\n                await pm.playUrls(_currentPlaylist);\r\n                await pm.setLoopMode(LoopMode.all);\r\n              }\r\n            } else {\r\n              await pm.player.play();\r\n            }\r\n            await pm.setVol(originalVol); // ensure volume is restored\r\n          } catch (e) { print('Restore music error: $e'); }\r\n        }"
);

// Also fix error recovery in announcement catch
rep('Fix error recovery in announcement catch to restart if needed',
  "        // Resume music if not already playing\r\n        try { final p2=context.read<PlayerModel>(); await p2.annPlayer.stop(); if(!p2.player.playing&&_wasPlayingBeforeAnnouncement) await p2.player.play(); } catch(_){}",
  "        // Resume music on error\r\n        try {\r\n          final p2 = context.read<PlayerModel>();\r\n          await p2.annPlayer.stop();\r\n          _isPlayingAnnouncement = false;\r\n          if (!p2.player.playing && _wasPlayingBeforeAnnouncement && _currentPlaylist.isNotEmpty) {\r\n            if (p2.player.processingState == ProcessingState.completed || p2.player.processingState == ProcessingState.idle) {\r\n              await p2.playUrls(_currentPlaylist);\r\n              await p2.setLoopMode(LoopMode.all);\r\n            } else {\r\n              await p2.player.play();\r\n            }\r\n          }\r\n        } catch (_) {}"
);

// ═══════════════════════════════════════════════════════════
// FIX 5: AI Announcement dialog - add quantity, editable text, voice preview
// ═══════════════════════════════════════════════════════════
rep('Replace AI dialog with full-featured version',
  "  void _showGenerateAIDialog() {\r\n    final topicCtrl = TextEditingController();\r\n    final toneCtrl = TextEditingController();\r\n    final keyPointsCtrl = TextEditingController();\r\n    \r\n    showDialog(\r\n      context: context,\r\n      builder: (ctx) => AlertDialog(\r\n        backgroundColor: const Color(0xFF2A2A2A),\r\n        title: const Text('Generate with AI', style: TextStyle(color: Colors.white)),\r\n        content: SingleChildScrollView(\r\n          child: Column(\r\n            mainAxisSize: MainAxisSize.min,\r\n            children: [\r\n              TextField(controller: topicCtrl, decoration: const InputDecoration(hintText: 'Topic (e.g. Closing Soon)'), style: const TextStyle(color: Colors.white)),\r\n              const SizedBox(height: 12),\r\n              TextField(controller: toneCtrl, decoration: const InputDecoration(hintText: 'Tone (e.g. Friendly)'), style: const TextStyle(color: Colors.white)),\r\n              const SizedBox(height: 12),\r\n              TextField(controller: keyPointsCtrl, decoration: const InputDecoration(hintText: 'Key Points'), maxLines: 3, style: const TextStyle(color: Colors.white)),\r\n            ],\r\n          ),\r\n        ),\r\n        actions: [\r\n          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),\r\n          FilledButton(\r\n            onPressed: () async {\r\n              Navigator.pop(ctx);\r\n              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Generating...')));\r\n              try {\r\n                final results = await generateAIAnnouncement(topicCtrl.text, toneCtrl.text, keyPointsCtrl.text);\r\n                if (mounted) _showAIResults(results);\r\n              } catch (e) {\r\n                if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Generation failed')));\r\n              }\r\n            },\r\n            child: const Text('Generate'),\r\n          ),\r\n        ],\r\n      )\r\n    );\r\n  }",
  "  void _showGenerateAIDialog() {\r\n    final topicCtrl = TextEditingController();\r\n    String tone = 'professional';\r\n    final keyPointsCtrl = TextEditingController();\r\n    int quantity = 3;\r\n\r\n    showDialog(\r\n      context: context,\r\n      builder: (ctx) => StatefulBuilder(\r\n        builder: (ctx, setState2) => AlertDialog(\r\n          backgroundColor: const Color(0xFF2A2A2A),\r\n          title: const Text('Generate with AI', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),\r\n          content: SingleChildScrollView(\r\n            child: Column(\r\n              mainAxisSize: MainAxisSize.min,\r\n              crossAxisAlignment: CrossAxisAlignment.start,\r\n              children: [\r\n                const Text('Topic *', style: TextStyle(color: Colors.grey, fontSize: 12)),\r\n                const SizedBox(height: 4),\r\n                TextField(controller: topicCtrl, decoration: const InputDecoration(hintText: 'e.g. Store closing in 30 minutes', filled: true, fillColor: Color(0xFF1A1A1A)), style: const TextStyle(color: Colors.white)),\r\n                const SizedBox(height: 12),\r\n                const Text('Tone', style: TextStyle(color: Colors.grey, fontSize: 12)),\r\n                const SizedBox(height: 4),\r\n                DropdownButtonFormField<String>(\r\n                  value: tone,\r\n                  dropdownColor: const Color(0xFF2A2A2A),\r\n                  style: const TextStyle(color: Colors.white),\r\n                  decoration: const InputDecoration(filled: true, fillColor: Color(0xFF1A1A1A)),\r\n                  items: const [\r\n                    DropdownMenuItem(value: 'professional', child: Text('Professional')),\r\n                    DropdownMenuItem(value: 'friendly', child: Text('Friendly')),\r\n                    DropdownMenuItem(value: 'urgent', child: Text('Urgent')),\r\n                    DropdownMenuItem(value: 'cheerful', child: Text('Cheerful')),\r\n                    DropdownMenuItem(value: 'formal', child: Text('Formal')),\r\n                  ],\r\n                  onChanged: (v) => setState2(() => tone = v ?? 'professional'),\r\n                ),\r\n                const SizedBox(height: 12),\r\n                const Text('Key Points (optional)', style: TextStyle(color: Colors.grey, fontSize: 12)),\r\n                const SizedBox(height: 4),\r\n                TextField(controller: keyPointsCtrl, decoration: const InputDecoration(hintText: 'e.g. 20% off, today only', filled: true, fillColor: Color(0xFF1A1A1A)), maxLines: 2, style: const TextStyle(color: Colors.white)),\r\n                const SizedBox(height: 12),\r\n                Row(mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [\r\n                  const Text('Quantity', style: TextStyle(color: Colors.grey, fontSize: 12)),\r\n                  Container(padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4), decoration: BoxDecoration(color: const Color(0xFF1DB954), borderRadius: BorderRadius.circular(4)), child: Text('$quantity', style: const TextStyle(color: Colors.black, fontWeight: FontWeight.bold))),\r\n                ]),\r\n                Slider(\r\n                  value: quantity.toDouble(), min: 1, max: 10, divisions: 9,\r\n                  activeColor: const Color(0xFF1DB954),\r\n                  onChanged: (v) => setState2(() => quantity = v.toInt()),\r\n                ),\r\n              ],\r\n            ),\r\n          ),\r\n          actions: [\r\n            TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),\r\n            FilledButton.icon(\r\n              icon: const Icon(Icons.auto_awesome, size: 16),\r\n              label: const Text('Generate'),\r\n              onPressed: () async {\r\n                if (topicCtrl.text.isEmpty) {\r\n                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Please enter a topic')));\r\n                  return;\r\n                }\r\n                Navigator.pop(ctx);\r\n                ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Generating $quantity announcement(s)...')));\r\n                try {\r\n                  final allResults = <Map<String, String>>[];\r\n                  // Generate in batches if needed\r\n                  final batchSize = quantity > 5 ? 5 : quantity;\r\n                  final results1 = await generateAIAnnouncement(topicCtrl.text, tone, keyPointsCtrl.text);\r\n                  allResults.addAll(results1.take(batchSize));\r\n                  if (quantity > 5) {\r\n                    final results2 = await generateAIAnnouncement('\${topicCtrl.text} variation', tone, keyPointsCtrl.text);\r\n                    allResults.addAll(results2.take(quantity - batchSize));\r\n                  }\r\n                  if (mounted) _showAIResults(allResults.take(quantity).toList());\r\n                } catch (e) {\r\n                  if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Generation failed: $e')));\r\n                }\r\n              },\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }"
);

// ═══════════════════════════════════════════════════════════
// FIX 6: AI Results - make text editable + voice preview
// ═══════════════════════════════════════════════════════════
rep('Replace _showAIResults with editable version',
  "  void _showAIResults(List<Map<String, String>> results) {\r\n    showDialog(\r\n      context: context,\r\n      builder: (ctx) => AlertDialog(\r\n        backgroundColor: const Color(0xFF2A2A2A),\r\n        title: const Text('AI Suggestions', style: TextStyle(color: Colors.white)),\r\n        content: SizedBox(\r\n          width: double.maxFinite,\r\n          child: ListView.separated(\r\n            shrinkWrap: true,\r\n            itemCount: results.length,\r\n            separatorBuilder: (_, __) => const Divider(color: Colors.grey),\r\n            itemBuilder: (c, i) => ListTile(\r\n              title: Text(results[i]['title'] ?? '', style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              subtitle: Text(results[i]['text'] ?? '', maxLines: 3, overflow: TextOverflow.ellipsis),\r\n              onTap: () {\r\n                Navigator.pop(ctx);\r\n                _saveGeneratedAnnouncement(results[i]['title']!, results[i]['text']!);\r\n              },\r\n            ),\r\n          ),\r\n        ),\r\n      )\r\n    );\r\n  }",
  "  void _showAIResults(List<Map<String, String>> results) {\r\n    // Create editable controllers for each result\r\n    final titleCtrls = results.map((r) => TextEditingController(text: r['title'] ?? '')).toList();\r\n    final textCtrls = results.map((r) => TextEditingController(text: r['text'] ?? '')).toList();\r\n    final selected = List<bool>.filled(results.length, true);\r\n\r\n    showDialog(\r\n      context: context,\r\n      builder: (ctx) => StatefulBuilder(\r\n        builder: (ctx, setState2) => AlertDialog(\r\n          backgroundColor: const Color(0xFF2A2A2A),\r\n          title: Row(children: [\r\n            const Icon(Icons.auto_awesome, color: Color(0xFF1DB954), size: 20),\r\n            const SizedBox(width: 8),\r\n            Text('\${results.length} AI Suggestion\${results.length==1?'\"\"\"':'s\"\"\"'}', style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),\r\n          ]),\r\n          content: SizedBox(\r\n            width: double.maxFinite,\r\n            height: 500,\r\n            child: ListView.builder(\r\n              itemCount: results.length,\r\n              itemBuilder: (c, i) => Container(\r\n                margin: const EdgeInsets.only(bottom: 12),\r\n                decoration: BoxDecoration(\r\n                  color: selected[i] ? const Color(0xFF1A1A1A) : const Color(0xFF111111),\r\n                  borderRadius: BorderRadius.circular(8),\r\n                  border: Border.all(color: selected[i] ? const Color(0xFF1DB954).withOpacity(0.5) : Colors.grey.withOpacity(0.2)),\r\n                ),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [\r\n                    Row(children: [\r\n                      Checkbox(\r\n                        value: selected[i],\r\n                        onChanged: (v) => setState2(() => selected[i] = v ?? true),\r\n                        activeColor: const Color(0xFF1DB954),\r\n                      ),\r\n                      const Text('Title', style: TextStyle(color: Colors.grey, fontSize: 11)),\r\n                      const Spacer(),\r\n                      // Preview button\r\n                      TextButton.icon(\r\n                        onPressed: () async {\r\n                          final pm = context.read<PlayerModel>();\r\n                          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Creating preview...'), duration: Duration(seconds: 1)));\r\n                          try {\r\n                            await createTTSAnnouncement(titleCtrls[i].text, textCtrls[i].text, folderId: null, zoneId: null);\r\n                            ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Saved - check Announcements to preview')));\r\n                          } catch (e) {\r\n                            ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Preview failed: $e')));\r\n                          }\r\n                        },\r\n                        icon: const Icon(Icons.play_circle, size: 14, color: Color(0xFF1DB954)),\r\n                        label: const Text('Save & Preview', style: TextStyle(fontSize: 11, color: Color(0xFF1DB954))),\r\n                        style: TextButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 6)),\r\n                      ),\r\n                    ]),\r\n                    TextField(\r\n                      controller: titleCtrls[i],\r\n                      style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 13),\r\n                      decoration: const InputDecoration(isDense: true, contentPadding: EdgeInsets.symmetric(horizontal: 4, vertical: 4), border: InputBorder.none),\r\n                    ),\r\n                    const SizedBox(height: 4),\r\n                    const Text('Script', style: TextStyle(color: Colors.grey, fontSize: 11)),\r\n                    TextField(\r\n                      controller: textCtrls[i],\r\n                      style: const TextStyle(color: Colors.white70, fontSize: 12),\r\n                      maxLines: 4,\r\n                      decoration: const InputDecoration(isDense: true, contentPadding: EdgeInsets.symmetric(horizontal: 4, vertical: 4), border: InputBorder.none),\r\n                    ),\r\n                  ]),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n          actions: [\r\n            TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),\r\n            TextButton(\r\n              onPressed: () => setState2(() { for (int i=0;i<selected.length;i++) selected[i]=true; }),\r\n              child: const Text('Select All'),\r\n            ),\r\n            FilledButton(\r\n              onPressed: () async {\r\n                Navigator.pop(ctx);\r\n                int created = 0;\r\n                for (int i = 0; i < results.length; i++) {\r\n                  if (selected[i]) {\r\n                    try {\r\n                      await _saveGeneratedAnnouncement(titleCtrls[i].text, textCtrls[i].text);\r\n                      created++;\r\n                    } catch (_) {}\r\n                  }\r\n                }\r\n                if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Created \$created announcement(s) ✓')));\r\n              },\r\n              child: Text('Create Selected (\${selected.where((s)=>s).length})'),\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }"
);

fs.writeFileSync('lib/main.dart.tmp', c, 'utf8');
const o=(c.match(/{/g)||[]).length, cl=(c.match(/}/g)||[]).length;
const op=(c.match(/\(/g)||[]).length, cp=(c.match(/\)/g)||[]).length;
console.log('\n=== DONE:', n, 'fixes | Braces:', o-cl, '| Parens:', op-cp, '===');


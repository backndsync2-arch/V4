const fs = require('fs');
const p = 'lib/main.dart';
let c = fs.readFileSync(p, 'utf8');
let fixes = 0;

function apply(desc, oldStr, newStr) {
  if (c.includes(oldStr)) {
    c = c.replace(oldStr, newStr);
    fixes++;
    console.log('✓ ' + desc);
  } else {
    console.log('✗ SKIP: ' + desc);
  }
}

// ═══════════════════════════════════════════════════════════════
// FIX 1: Add separate AudioPlayer + stop() to PlayerModel
// ═══════════════════════════════════════════════════════════════
apply('PlayerModel: add stop(), clear(), annPlayer',
  "class PlayerModel extends ChangeNotifier {\r\n  final AudioPlayer player = AudioPlayer();\r\n  String? currentTitle;",
  "class PlayerModel extends ChangeNotifier {\r\n  final AudioPlayer player = AudioPlayer();\r\n  final AudioPlayer annPlayer = AudioPlayer(); // dedicated for announcements\r\n  String? currentTitle;\r\n  bool get hasContent => currentTitle != null;"
);

// Add stop/clear methods before playUrl
apply('PlayerModel: add stop() and dismiss()',
  "  Future<void> playUrl(String url, String title) async {",
  "  Future<void> stop() async {\r\n    await player.stop();\r\n    playing = false;\r\n    currentTitle = null;\r\n    _playlistTitles = [];\r\n    notifyListeners();\r\n  }\r\n\r\n  Future<void> dismiss() async {\r\n    await player.stop();\r\n    await annPlayer.stop();\r\n    playing = false;\r\n    currentTitle = null;\r\n    _playlistTitles = [];\r\n    notifyListeners();\r\n  }\r\n\r\n  Future<void> playUrl(String url, String title) async {"
);

// ═══════════════════════════════════════════════════════════════
// FIX 2: Mini Player - add close button + tap to open full player
// ═══════════════════════════════════════════════════════════════
apply('MiniPlayer: show only when playing (not just title != null)',
  "          if (player.currentTitle != null)\r\n            Positioned(\r\n              left: 8, right: 8, bottom: 8,\r\n              child: _MiniPlayer(),\r\n            ),",
  "          if (player.hasContent)\r\n            Positioned(\r\n              left: 8, right: 8, bottom: 8,\r\n              child: _MiniPlayer(),\r\n            ),"
);

// ═══════════════════════════════════════════════════════════════
// FIX 3: Announcement playback using annPlayer (separate)
// ═══════════════════════════════════════════════════════════════
apply('Ann: use annPlayer instead of pm.player for announcement audio',
  "        // Pause music and play announcement using the same player\r\n        await pm.pause();\r\n        \r\n        // Create announcement source - pre-resolve redirect to S3\r\n        final annHeaders = <String, String>{};\r\n        if (token != null && token.isNotEmpty) {\r\n          annHeaders['Authorization'] = 'Bearer $token';\r\n        }\r\n        String resolvedAnnUrl = announcementUrl;\r\n        try {\r\n          final annIsApi = announcementUrl.contains('/api/v1/') || announcementUrl.contains('execute-api');\r\n          if (annIsApi && annHeaders.isNotEmpty) {\r\n            final annClient = HttpClient();\r\n            final annReq = await annClient.headUrl(Uri.parse(announcementUrl));\r\n            annReq.followRedirects = false;\r\n            annHeaders.forEach((k, v) => annReq.headers.set(k, v));\r\n            final annRes = await annReq.close().timeout(const Duration(seconds: 10));\r\n            if (annRes.statusCode == 302 || annRes.statusCode == 301) {\r\n              final loc = annRes.headers.value('location');\r\n              if (loc != null && loc.isNotEmpty) { resolvedAnnUrl = loc; print('Ann resolved to S3: $resolvedAnnUrl'); }\r\n            }\r\n            annClient.close(force: true);\r\n          }\r\n        } catch (_) {}\r\n        final annIsS3 = resolvedAnnUrl.contains('X-Amz-') || (resolvedAnnUrl.contains('amazonaws.com') && !resolvedAnnUrl.contains('/api/'));\r\n        final annSource = AudioSource.uri(\r\n          Uri.parse(resolvedAnnUrl),\r\n          headers: annIsS3 ? null : (annHeaders.isNotEmpty ? annHeaders : null)\r\n        );\r\n        \r\n        // Play announcement\r\n        await pm.player.setAudioSource(annSource);\r\n        await pm.player.setVolume(annVol);\r\n        print('Playing announcement audio');\r\n        await pm.player.play();\r\n        print('Announcement play() called, checking if playing...');\r\n        \r\n        // Wait until announcement completes\r\n        await pm.player.playerStateStream.firstWhere((s) => s.processingState == ProcessingState.completed);",
  "        // Fade music volume down\r\n        // (music keeps playing quietly during announcement)\r\n        \r\n        // Create announcement source - pre-resolve redirect to S3\r\n        final annHeaders = <String, String>{};\r\n        if (token != null && token.isNotEmpty) {\r\n          annHeaders['Authorization'] = 'Bearer $token';\r\n        }\r\n        String resolvedAnnUrl = announcementUrl;\r\n        try {\r\n          final annIsApi = announcementUrl.contains('/api/v1/') || announcementUrl.contains('execute-api');\r\n          if (annIsApi && annHeaders.isNotEmpty) {\r\n            final annClient = HttpClient();\r\n            final annReq = await annClient.headUrl(Uri.parse(announcementUrl));\r\n            annReq.followRedirects = false;\r\n            annHeaders.forEach((k, v) => annReq.headers.set(k, v));\r\n            final annRes = await annReq.close().timeout(const Duration(seconds: 10));\r\n            if (annRes.statusCode == 302 || annRes.statusCode == 301) {\r\n              final loc = annRes.headers.value('location');\r\n              if (loc != null && loc.isNotEmpty) { resolvedAnnUrl = loc; print('Ann resolved to S3: $resolvedAnnUrl'); }\r\n            }\r\n            annClient.close(force: true);\r\n          }\r\n        } catch (_) {}\r\n        final annIsS3 = resolvedAnnUrl.contains('X-Amz-') || (resolvedAnnUrl.contains('amazonaws.com') && !resolvedAnnUrl.contains('/api/'));\r\n        final annSource = AudioSource.uri(\r\n          Uri.parse(resolvedAnnUrl),\r\n          headers: annIsS3 ? null : (annHeaders.isNotEmpty ? annHeaders : null)\r\n        );\r\n        \r\n        // Use DEDICATED annPlayer - music player keeps playing quietly\r\n        await pm.annPlayer.setVolume(annVol);\r\n        await pm.annPlayer.setAudioSource(annSource);\r\n        print('Playing announcement via dedicated annPlayer');\r\n        await pm.annPlayer.play();\r\n        print('Announcement play() called');\r\n        \r\n        // Wait until announcement completes\r\n        await pm.annPlayer.playerStateStream.firstWhere((s) => s.processingState == ProcessingState.completed || (!s.playing && s.processingState == ProcessingState.idle)).timeout(const Duration(seconds: 120), onTimeout: () => pm.annPlayer.playerState);"
);

// Fix the restore section after announcement - no need to reload music since it kept playing
apply('Ann: after announcement, restore music volume (no reload needed)',
  "        // Restore music playback if it was playing before\r\n        if (_wasPlayingBeforeAnnouncement) {\r\n          // Reload the original playlist\r\n          final items = _allMusic.where((m) => _selectedMusicIds.contains((m['id'] ?? m['file_id'] ?? m['music_file_id'] ?? '').toString()))\r\n            .map((m) {\r\n              String url = (m['stream_url'] ?? m['file_url'] ?? m['url'] ?? '').toString();\r\n              // Don't add token to URL - playUrls() will handle auth via headers\r\n              return {\r\n                'url': url,\r\n                'title': (m['name'] ?? m['title'] ?? 'Unknown').toString(),\r\n              };\r\n            }).where((e) => (e['url'] ?? '').isNotEmpty).toList();\r\n\r\n          if (items.isNotEmpty) {\r\n            await pm.playUrls(items);\r\n            await pm.setLoopMode(LoopMode.all);\r\n            // Seek to previous position if available\r\n            if (_previousIndex != null && _previousIndex! > 0) {\r\n              await pm.player.seek(Duration.zero, index: _previousIndex);\r\n            }\r\n          }\r\n        }",
  "        // Music kept playing during announcement - just restore volume\r\n        if (!pm.player.playing && _wasPlayingBeforeAnnouncement) {\r\n          await pm.player.play();\r\n        }\r\n        await pm.annPlayer.stop();"
);

// Fix error recovery in announcement catch block
apply('Ann: fix error recovery (no need to reload)',
  "        // Resume music if announcement fails\r\n        if (_wasPlayingBeforeAnnouncement) {\r\n          try {\r\n            final items = _allMusic.where((m) => _selectedMusicIds.contains((m['id'] ?? m['file_id'] ?? m['music_file_id'] ?? '').toString()))\r\n              .map((m) {\r\n                String url = (m['stream_url'] ?? m['file_url'] ?? m['url'] ?? '').toString();\r\n                // Don't add token to URL - playUrls() will handle auth via headers\r\n                return {\r\n                  'url': url,\r\n                  'title': (m['name'] ?? m['title'] ?? 'Unknown').toString(),\r\n                };\r\n              }).where((e) => (e['url'] ?? '').isNotEmpty).toList();\r\n            if (items.isNotEmpty) {\r\n              await pm.playUrls(items);\r\n              await pm.setLoopMode(LoopMode.all);\r\n            }\r\n          } catch (_) {}\r\n        }",
  "        // Resume music if not already playing\r\n        try {\r\n          await pm.annPlayer.stop();\r\n          if (!pm.player.playing && _wasPlayingBeforeAnnouncement) await pm.player.play();\r\n        } catch (_) {}"
);

// ═══════════════════════════════════════════════════════════════
// FIX 4: MiniPlayer - add close button and close-on-stop state
// ═══════════════════════════════════════════════════════════════
apply('MiniPlayer: replace build with version including close button',
  "class _MiniPlayer extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {",
  "class _MiniPlayer extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    // hasContent check already done in parent Positioned condition"
);

// Find the MiniPlayer's inner content and add close button
apply('MiniPlayer: add close × button',
  "            IconButton(\r\n              icon: Icon(player.playing ? Icons.pause : Icons.play_arrow, color: Colors.white),\r\n              onPressed: () => player.playing ? player.pause() : player.player.play(),\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass ThemeModel",
  "            IconButton(\r\n              icon: Icon(player.playing ? Icons.pause : Icons.play_arrow, color: Colors.white),\r\n              onPressed: () => player.playing ? player.pause() : player.player.play(),\r\n            ),\r\n            IconButton(\r\n              icon: const Icon(Icons.close, color: Colors.white70, size: 18),\r\n              onPressed: () => player.dismiss(),\r\n              tooltip: 'Close player',\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass ThemeModel"
);

// ═══════════════════════════════════════════════════════════════
// FIX 5: Dashboard - Add Stop button
// ═══════════════════════════════════════════════════════════════
apply('Dashboard: add Stop button next to Pause',
  "                    // Start/Stop Button\r\n                    SizedBox(\r\n                      width: double.infinity,\r\n                      height: 56,\r\n                      child: ElevatedButton.icon(\r\n                        onPressed: _togglePlayback,\r\n                        icon: Icon(isPlaying ? Icons.pause : Icons.play_arrow),\r\n                        label: Text(isPlaying ? 'Pause Playback' : 'Start Playback', style: const TextStyle(fontSize: 18)),\r\n                        style: ElevatedButton.styleFrom(\r\n                          backgroundColor: isPlaying ? Colors.red : const Color(0xFF1DB954),\r\n                          foregroundColor: Colors.white,\r\n                        ),\r\n                      ),\r\n                    ),",
  "                    // Start/Stop Buttons\r\n                    Row(\r\n                      children: [\r\n                        Expanded(\r\n                          flex: 3,\r\n                          child: SizedBox(\r\n                            height: 56,\r\n                            child: ElevatedButton.icon(\r\n                              onPressed: _togglePlayback,\r\n                              icon: Icon(isPlaying ? Icons.pause : Icons.play_arrow),\r\n                              label: Text(isPlaying ? 'Pause' : 'Start', style: const TextStyle(fontSize: 16)),\r\n                              style: ElevatedButton.styleFrom(\r\n                                backgroundColor: isPlaying ? const Color(0xFF1565C0) : const Color(0xFF1DB954),\r\n                                foregroundColor: Colors.white,\r\n                              ),\r\n                            ),\r\n                          ),\r\n                        ),\r\n                        const SizedBox(width: 8),\r\n                        if (isPlaying) Expanded(\r\n                          flex: 2,\r\n                          child: SizedBox(\r\n                            height: 56,\r\n                            child: ElevatedButton.icon(\r\n                              onPressed: () {\r\n                                _announcementTimer?.cancel();\r\n                                _countdownTimer?.cancel();\r\n                                setState(() => _playbackState = {'is_playing': false});\r\n                                context.read<PlayerModel>().stop();\r\n                              },\r\n                              icon: const Icon(Icons.stop),\r\n                              label: const Text('Stop', style: TextStyle(fontSize: 16)),\r\n                              style: ElevatedButton.styleFrom(backgroundColor: Colors.red.shade800, foregroundColor: Colors.white),\r\n                            ),\r\n                          ),\r\n                        ),\r\n                      ],\r\n                    ),"
);

// ═══════════════════════════════════════════════════════════════
// FIX 6: Dashboard - Add volume slider for zone
// ═══════════════════════════════════════════════════════════════
apply('Dashboard: add zone volume slider after Stop button',
  "                    const SizedBox(height: 12),\r\n                    SizedBox(\r\n                      width: double.infinity,\r\n                      height: 44,\r\n                      child: OutlinedButton(\r\n                        onPressed: _playNextAnnouncement,\r\n                        child: const Text('Play Announcement Now'),\r\n                      ),\r\n                    ),",
  "                    const SizedBox(height: 8),\r\n                    // Volume + Play Announcement Now\r\n                    if (isPlaying) Container(\r\n                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),\r\n                      decoration: BoxDecoration(color: const Color(0xFF1A1A1A), borderRadius: BorderRadius.circular(8)),\r\n                      child: Row(\r\n                        children: [\r\n                          const Icon(Icons.volume_down, color: Colors.grey, size: 18),\r\n                          Expanded(\r\n                            child: Slider(\r\n                              value: context.read<PlayerModel>().volume,\r\n                              min: 0, max: 1,\r\n                              onChanged: (v) {\r\n                                context.read<PlayerModel>().setVol(v);\r\n                                setState(() {});\r\n                              },\r\n                            ),\r\n                          ),\r\n                          const Icon(Icons.volume_up, color: Colors.grey, size: 18),\r\n                          const SizedBox(width: 8),\r\n                          Text('${(context.read<PlayerModel>().volume*100).round()}%', style: const TextStyle(color: Colors.grey, fontSize: 12)),\r\n                        ],\r\n                      ),\r\n                    ),\r\n                    const SizedBox(height: 8),\r\n                    SizedBox(\r\n                      width: double.infinity,\r\n                      height: 44,\r\n                      child: OutlinedButton.icon(\r\n                        onPressed: _playNextAnnouncement,\r\n                        icon: const Icon(Icons.campaign, size: 18),\r\n                        label: const Text('Play Announcement Now'),\r\n                      ),\r\n                    ),"
);

// ═══════════════════════════════════════════════════════════════
// FIX 7: Persist announcement settings
// ═══════════════════════════════════════════════════════════════
apply('Dashboard: load saved settings in initState',
  "  @override\r\n  void initState() {\r\n    super.initState();\r\n    _initData();\r\n  }",
  "  @override\r\n  void initState() {\r\n    super.initState();\r\n    _loadSavedSettings();\r\n    _initData();\r\n  }\r\n\r\n  Future<void> _loadSavedSettings() async {\r\n    final prefs = await SharedPreferences.getInstance();\r\n    if (mounted) setState(() {\r\n      _announcementInterval = prefs.getDouble('ann_interval') ?? 300;\r\n      _fadeDuration = prefs.getDouble('ann_fade') ?? 3;\r\n      _musicVolume = prefs.getDouble('ann_music_vol') ?? 20;\r\n      _announcementVolume = prefs.getDouble('ann_vol') ?? 100;\r\n    });\r\n  }\r\n\r\n  Future<void> _saveSettings() async {\r\n    final prefs = await SharedPreferences.getInstance();\r\n    await prefs.setDouble('ann_interval', _announcementInterval);\r\n    await prefs.setDouble('ann_fade', _fadeDuration);\r\n    await prefs.setDouble('ann_music_vol', _musicVolume);\r\n    await prefs.setDouble('ann_vol', _announcementVolume);\r\n  }"
);

// Save settings when sliders change
apply('Dashboard: save settings when interval slider changes',
  "_buildSlider('Announcement Interval', _announcementInterval, 10, 1800, (v) => setState(() => _announcementInterval = v), _formatDuration(_announcementInterval)),",
  "_buildSlider('Announcement Interval', _announcementInterval, 10, 1800, (v) { setState(() => _announcementInterval = v); _saveSettings(); }, _formatDuration(_announcementInterval)),"
);
apply('Dashboard: save settings when fade slider changes',
  "_buildSlider('Fade Duration', _fadeDuration, 1, 10, (v) => setState(() => _fadeDuration = v), '${_fadeDuration.toInt()}s'),",
  "_buildSlider('Fade Duration', _fadeDuration, 1, 10, (v) { setState(() => _fadeDuration = v); _saveSettings(); }, '${_fadeDuration.toInt()}s'),"
);
apply('Dashboard: save settings when music vol slider changes',
  "_buildSlider('Music Volume During Announcement', _musicVolume, 0, 100, (v) => setState(() => _musicVolume = v), '${_musicVolume.toInt()}%'),",
  "_buildSlider('Music Volume During Announcement', _musicVolume, 0, 100, (v) { setState(() => _musicVolume = v); _saveSettings(); }, '${_musicVolume.toInt()}%'),"
);
apply('Dashboard: save settings when ann vol slider changes',
  "_buildSlider('Announcement Volume', _announcementVolume, 0, 100, (v) => setState(() => _announcementVolume = v), '${_announcementVolume.toInt()}%'),",
  "_buildSlider('Announcement Volume', _announcementVolume, 0, 100, (v) { setState(() => _announcementVolume = v); _saveSettings(); }, '${_announcementVolume.toInt()}%'),"
);

// ═══════════════════════════════════════════════════════════════
// FIX 8: Music Page - add search bar + pull-to-refresh + delete/rename
// ═══════════════════════════════════════════════════════════════
apply('MusicPage: add search field state variable',
  "class _MusicPageState extends State<MusicPage> {\r\n  String? _zoneId;",
  "class _MusicPageState extends State<MusicPage> {\r\n  String? _zoneId;\r\n  String _searchQuery = '';\r\n  final _searchCtrl = TextEditingController();"
);

apply('MusicPage: add search bar above folder/file list',
  "          Expanded(\r\n            child: music.loading\r\n                ? const Center(child: CircularProgressIndicator())\r\n                : Padding(\r\n                    padding: const EdgeInsets.all(16),\r\n                    child: CustomScrollView(",
  "          // Search bar\r\n          Padding(\r\n            padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),\r\n            child: TextField(\r\n              controller: _searchCtrl,\r\n              decoration: InputDecoration(\r\n                hintText: 'Search music...',\r\n                prefixIcon: const Icon(Icons.search, size: 20),\r\n                suffixIcon: _searchQuery.isNotEmpty ? IconButton(icon: const Icon(Icons.clear, size: 18), onPressed: () { _searchCtrl.clear(); setState(() => _searchQuery = ''); }) : null,\r\n                contentPadding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),\r\n                isDense: true,\r\n              ),\r\n              onChanged: (v) => setState(() => _searchQuery = v.toLowerCase()),\r\n            ),\r\n          ),\r\n          Expanded(\r\n            child: music.loading\r\n                ? const Center(child: CircularProgressIndicator())\r\n                : RefreshIndicator(\r\n                    onRefresh: () => music.load(folderId: music.currentFolderId),\r\n                    child: Padding(\r\n                    padding: const EdgeInsets.all(16),\r\n                    child: CustomScrollView("
);

// Close the extra RefreshIndicator
apply('MusicPage: close RefreshIndicator and extra Padding after CustomScrollView',
  "                  ),\r\n                ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  void _showCreateFolderDialog(BuildContext context) {",
  "                    ),\r\n                  ),\r\n                ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  void _showCreateFolderDialog(BuildContext context) {"
);

// Filter music files by search
apply('MusicPage: filter files by search',
  "                      // Files Section (List)\r\n                      if (music.files.isNotEmpty) ...[\r\n                        const SliverToBoxAdapter(child: Padding(padding: EdgeInsets.only(bottom: 8), child: Text('SONGS', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)))),\r\n                        SliverList(\r\n                          delegate: SliverChildBuilderDelegate(\r\n                            (ctx, i) {\r\n                              final file = music.files[i];\r\n                              return _FileListItem(\r\n                                file: file,\r\n                                zoneId: zoneId,\r\n                              );\r\n                            },\r\n                            childCount: music.files.length,\r\n                          ),\r\n                        ),\r\n                      ]",
  "                      // Files Section (List)\r\n                      if (music.files.isNotEmpty) ...[\r\n                        const SliverToBoxAdapter(child: Padding(padding: EdgeInsets.only(bottom: 8), child: Text('SONGS', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)))),\r\n                        SliverList(\r\n                          delegate: SliverChildBuilderDelegate(\r\n                            (ctx, i) {\r\n                              final filtered = _searchQuery.isEmpty ? music.files : music.files.where((f) => (f['title'] ?? f['name'] ?? '').toString().toLowerCase().contains(_searchQuery)).toList();\r\n                              if (i >= filtered.length) return null;\r\n                              return _FileListItem(file: filtered[i], zoneId: zoneId, onDelete: () async {\r\n                                final id = (filtered[i]['id'] ?? '').toString();\r\n                                if (id.isEmpty) return;\r\n                                final ok = await showDialog<bool>(context: context, builder: (c) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Delete Song?', style: TextStyle(color: Colors.white)), content: Text('Delete \"${(filtered[i]['title'] ?? filtered[i]['name'] ?? 'this file')}\"?', style: const TextStyle(color: Colors.grey)), actions: [TextButton(onPressed: () => Navigator.pop(c, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(c, true), child: const Text('Delete'))]));\r\n                                if (ok == true) { try { await deleteMusicFile(id); music.load(folderId: music.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Delete failed: $e'))); } }\r\n                              }, onRename: () async {\r\n                                final id = (filtered[i]['id'] ?? '').toString();\r\n                                final ctrl = TextEditingController(text: (filtered[i]['title'] ?? filtered[i]['name'] ?? '').toString());\r\n                                final ok = await showDialog<bool>(context: context, builder: (c) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Rename', style: TextStyle(color: Colors.white)), content: TextField(controller: ctrl, style: const TextStyle(color: Colors.white), decoration: const InputDecoration(hintText: 'New name')), actions: [TextButton(onPressed: () => Navigator.pop(c, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(c, true), child: const Text('Rename'))]));\r\n                                if (ok == true && ctrl.text.isNotEmpty) { try { await updateMusicFile(id, title: ctrl.text); music.load(folderId: music.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Rename failed: $e'))); } }\r\n                              });\r\n                            },\r\n                            childCount: _searchQuery.isEmpty ? music.files.length : music.files.where((f) => (f['title'] ?? f['name'] ?? '').toString().toLowerCase().contains(_searchQuery)).length,\r\n                          ),\r\n                        ),\r\n                      ]"
);

// ═══════════════════════════════════════════════════════════════
// FIX 9: Folder cards - change from grid to list, add long-press menu
// ═══════════════════════════════════════════════════════════════
apply('Music: folder grid -> compact list style',
  "                      if (music.folders.isNotEmpty) ...[\r\n                        const SliverToBoxAdapter(child: Padding(padding: EdgeInsets.only(bottom: 8), child: Text('FOLDERS', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)))),\r\n                        SliverGrid(\r\n                          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\r\n                            crossAxisCount: 2,\r\n                            childAspectRatio: 1.2,\r\n                            crossAxisSpacing: 16,\r\n                            mainAxisSpacing: 16,\r\n                          ),\r\n                          delegate: SliverChildBuilderDelegate(\r\n                            (ctx, i) {\r\n                              final folder = music.folders[i];\r\n                              return _FolderCard(\r\n                                name: folder['name'] ?? 'Folder',\r\n                                onTap: () => music.enterFolder((folder['id'] ?? '').toString(), folder['name'] ?? 'Folder'),\r\n                                onPlay: zoneId == null ? null : () async {\r\n                                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Starting folder playback...')));\r\n                                  try {\r\n                                    final folderId = (folder['id'] ?? '').toString();\r\n                                    final files = await getMusicFiles(folderId: folderId);\r\n                                    final ids = files.map((f) => (f['id'] ?? '').toString()).toList();\r\n                                    if (ids.isNotEmpty) {\r\n                                      await playbackPlay(zoneId, musicFileIds: ids);\r\n                                    } else {\r\n                                      if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Folder is empty')));\r\n                                    }\r\n                                  } catch(e) {\r\n                                    if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Failed to play folder')));\r\n                                  }\r\n                                },\r\n                              );\r\n                            },\r\n                            childCount: music.folders.length,\r\n                          ),\r\n                        ),\r\n                        const SliverToBoxAdapter(child: SizedBox(height: 24)),\r\n                      ],",
  "                      if (music.folders.isNotEmpty) ...[\r\n                        const SliverToBoxAdapter(child: Padding(padding: EdgeInsets.only(bottom: 8), child: Text('FOLDERS', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)))),\r\n                        SliverList(\r\n                          delegate: SliverChildBuilderDelegate(\r\n                            (ctx, i) {\r\n                              final folder = music.folders[i];\r\n                              final fid = (folder['id'] ?? '').toString();\r\n                              return _FolderListTile(\r\n                                name: folder['name'] ?? 'Folder',\r\n                                onTap: () => music.enterFolder(fid, folder['name'] ?? 'Folder'),\r\n                                onPlay: zoneId == null ? null : () async {\r\n                                  try { final files = await getMusicFiles(folderId: fid); final ids = files.map((f) => (f['id'] ?? '').toString()).toList(); if (ids.isNotEmpty) { await playbackPlay(zoneId, musicFileIds: ids); } } catch(_) {}\r\n                                },\r\n                                onRename: () async {\r\n                                  final ctrl = TextEditingController(text: folder['name'] ?? '');\r\n                                  final ok = await showDialog<bool>(context: context, builder: (c) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Rename Folder', style: TextStyle(color: Colors.white)), content: TextField(controller: ctrl, style: const TextStyle(color: Colors.white), decoration: const InputDecoration(hintText: 'Folder name')), actions: [TextButton(onPressed: () => Navigator.pop(c, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(c, true), child: const Text('Rename'))]));\r\n                                  if (ok == true && ctrl.text.isNotEmpty) { try { await renameFolder(fid, ctrl.text); music.load(folderId: music.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e'))); } }\r\n                                },\r\n                                onDelete: () async {\r\n                                  final ok = await showDialog<bool>(context: context, builder: (c) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Delete Folder?', style: TextStyle(color: Colors.white)), content: Text('Delete \"${folder['name']}\"? All files inside will also be deleted.', style: const TextStyle(color: Colors.grey)), actions: [TextButton(onPressed: () => Navigator.pop(c, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(c, true), child: const Text('Delete'))]));\r\n                                  if (ok == true) { try { await deleteFolder(fid); music.load(folderId: music.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e'))); } }\r\n                                },\r\n                              );\r\n                            },\r\n                            childCount: music.folders.length,\r\n                          ),\r\n                        ),\r\n                        const SliverToBoxAdapter(child: SizedBox(height: 16)),\r\n                      ],"
);

// ═══════════════════════════════════════════════════════════════
// FIX 10: Update _FileListItem to accept onDelete and onRename callbacks
// ═══════════════════════════════════════════════════════════════
apply('_FileListItem: add onDelete and onRename callbacks',
  "class _FileListItem extends StatelessWidget {\r\n  final dynamic file;\r\n  final String? zoneId;\r\n  const _FileListItem({required this.file, this.zoneId});",
  "class _FileListItem extends StatelessWidget {\r\n  final dynamic file;\r\n  final String? zoneId;\r\n  final VoidCallback? onDelete;\r\n  final VoidCallback? onRename;\r\n  const _FileListItem({required this.file, this.zoneId, this.onDelete, this.onRename});"
);

apply('_FileListItem: add long-press for delete/rename',
  "    return Container(\r\n      margin: const EdgeInsets.only(bottom: 8),\r\n      decoration: BoxDecoration(\r\n        color: const Color(0xFF181818),\r\n        borderRadius: BorderRadius.circular(4),\r\n      ),\r\n      child: ListTile(",
  "    return GestureDetector(\r\n      onLongPress: () {\r\n        showModalBottomSheet(context: context, backgroundColor: const Color(0xFF2A2A2A), builder: (c) => Column(\r\n          mainAxisSize: MainAxisSize.min,\r\n          children: [\r\n            ListTile(leading: const Icon(Icons.edit, color: Colors.white), title: const Text('Rename', style: TextStyle(color: Colors.white)), onTap: () { Navigator.pop(c); onRename?.call(); }),\r\n            ListTile(leading: const Icon(Icons.delete, color: Colors.red), title: const Text('Delete', style: TextStyle(color: Colors.red)), onTap: () { Navigator.pop(c); onDelete?.call(); }),\r\n            ListTile(leading: const Icon(Icons.close, color: Colors.grey), title: const Text('Cancel', style: TextStyle(color: Colors.grey)), onTap: () => Navigator.pop(c)),\r\n          ],\r\n        ));\r\n      },\r\n      child: Container(\r\n      margin: const EdgeInsets.only(bottom: 8),\r\n      decoration: BoxDecoration(\r\n        color: const Color(0xFF181818),\r\n        borderRadius: BorderRadius.circular(4),\r\n      ),\r\n      child: ListTile("
);

// Close the GestureDetector
apply('_FileListItem: close GestureDetector child',
  "      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _OptionItem",
  "      ),\r\n    ));\r\n  }\r\n}\r\n\r\nclass _OptionItem"
);

// ═══════════════════════════════════════════════════════════════
// FIX 11: Announcements Page - search + pull-to-refresh + delete/rename + list view
// ═══════════════════════════════════════════════════════════════
apply('AnnouncementsPage: add search state variable',
  "class _AnnouncementsPageState extends State<AnnouncementsPage> {",
  "class _AnnouncementsPageState extends State<AnnouncementsPage> {\r\n  String _searchQuery = '';\r\n  final _annSearchCtrl = TextEditingController();"
);

// Replace the announcements body with improved version (list + search + delete)
apply('AnnouncementsPage: replace GridView with improved ListView + search',
  "      body: model.loading \r\n          ? const Center(child: CircularProgressIndicator())\r\n          : Column(\r\n              children: [\r\n                if (canGoBack)\r\n                  Container(\r\n                    width: double.infinity,\r\n                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\r\n                    color: const Color(0xFF181818),\r\n                    child: Text(\r\n                      model.breadcrumbs.map((e) => e['name']).join(' > '),\r\n                      style: const TextStyle(color: Colors.grey),\r\n                    ),\r\n                  ),\r\n                Expanded(\r\n                  child: GridView.builder(\r\n                    padding: const EdgeInsets.all(16),\r\n                    gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\r\n                      crossAxisCount: 2,\r\n                      childAspectRatio: 0.8,\r\n                      crossAxisSpacing: 16,\r\n                      mainAxisSpacing: 16,\r\n                    ),\r\n                    itemCount: model.folders.length + model.files.length,\r\n                    itemBuilder: (ctx, i) {\r\n                      if (i < model.folders.length) {\r\n                        final folder = model.folders[i];\r\n                        return _FolderCard(\r\n                          name: folder['name'] ?? 'Folder',\r\n                          onTap: () => model.enterFolder((folder['id'] ?? '').toString(), folder['name'] ?? 'Folder'),\r\n                        );\r\n                      }\r\n                      \r\n                      final item = model.files[i - model.folders.length];\r\n                      final title = (item['title'] ?? item['name'] ?? 'Unknown').toString();\r\n                      final url = (item['file_url'] ?? item['url'] ?? '').toString();\r\n                      \r\n                      return Card(\r\n                        clipBehavior: Clip.antiAlias,\r\n                        color: const Color(0xFF181818),\r\n                        child: Column(\r\n                          crossAxisAlignment: CrossAxisAlignment.start,\r\n                          children: [\r\n                            Expanded(\r\n                              child: Container(\r\n                                color: const Color(0xFF282828),\r\n                                width: double.infinity,\r\n                                child: const Icon(Icons.campaign, size: 48, color: Colors.white),\r\n                              ),\r\n                            ),\r\n                            Padding(\r\n                              padding: const EdgeInsets.all(12),\r\n                              child: Column(\r\n                                crossAxisAlignment: CrossAxisAlignment.start,\r\n                                children: [\r\n                                  Text(title, maxLines: 1, overflow: TextOverflow.ellipsis, style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white)),\r\n                                  const SizedBox(height: 8),\r\n                                  Row(\r\n                                    mainAxisAlignment: MainAxisAlignment.spaceBetween,\r\n                                    children: [\r\n                                      IconButton(\r\n                                        icon: const Icon(Icons.play_circle_fill, color: Color(0xFF1DB954), size: 28),\r\n                                        padding: EdgeInsets.zero,\r\n                                        constraints: const BoxConstraints(),\r\n                                        onPressed: url.isEmpty ? null : () {\r\n                                          context.read<PlayerModel>().playUrl(url, title);\r\n                                        },\r\n                                      ),\r\n                                    ],\r\n                                  )\r\n                                ],\r\n                              ),\r\n                            ),\r\n                          ],\r\n                        ),\r\n                      );\r\n                    },\r\n                  ),\r\n                ),\r\n              ],\r\n            ),",
  "      body: model.loading\r\n          ? const Center(child: CircularProgressIndicator())\r\n          : Column(\r\n              children: [\r\n                if (canGoBack)\r\n                  Container(width: double.infinity, padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8), color: const Color(0xFF181818),\r\n                    child: Text(model.breadcrumbs.map((e) => e['name']).join(' > '), style: const TextStyle(color: Colors.grey))),\r\n                // Search bar\r\n                Padding(\r\n                  padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),\r\n                  child: TextField(\r\n                    controller: _annSearchCtrl,\r\n                    decoration: InputDecoration(\r\n                      hintText: 'Search announcements...',\r\n                      prefixIcon: const Icon(Icons.search, size: 20),\r\n                      suffixIcon: _searchQuery.isNotEmpty ? IconButton(icon: const Icon(Icons.clear, size: 18), onPressed: () { _annSearchCtrl.clear(); setState(() => _searchQuery = ''); }) : null,\r\n                      contentPadding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12), isDense: true,\r\n                    ),\r\n                    onChanged: (v) => setState(() => _searchQuery = v.toLowerCase()),\r\n                  ),\r\n                ),\r\n                Expanded(\r\n                  child: RefreshIndicator(\r\n                    onRefresh: () => model.load(folderId: model.currentFolderId),\r\n                    child: ListView.builder(\r\n                      padding: const EdgeInsets.all(12),\r\n                      itemCount: model.folders.length + model.files.where((f) => _searchQuery.isEmpty || (f['title'] ?? f['name'] ?? '').toString().toLowerCase().contains(_searchQuery)).length,\r\n                      itemBuilder: (ctx, i) {\r\n                        if (i < model.folders.length) {\r\n                          final folder = model.folders[i];\r\n                          final fid = (folder['id'] ?? '').toString();\r\n                          return _FolderListTile(\r\n                            name: folder['name'] ?? 'Folder',\r\n                            onTap: () => model.enterFolder(fid, folder['name'] ?? 'Folder'),\r\n                            onRename: () async {\r\n                              final ctrl = TextEditingController(text: folder['name'] ?? '');\r\n                              final ok = await showDialog<bool>(context: context, builder: (c) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Rename Folder', style: TextStyle(color: Colors.white)), content: TextField(controller: ctrl, style: const TextStyle(color: Colors.white), decoration: const InputDecoration(hintText: 'Folder name')), actions: [TextButton(onPressed: () => Navigator.pop(c, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(c, true), child: const Text('Rename'))]));\r\n                              if (ok == true && ctrl.text.isNotEmpty) { try { await renameFolder(fid, ctrl.text); model.load(folderId: model.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e'))); } }\r\n                            },\r\n                            onDelete: () async {\r\n                              final ok = await showDialog<bool>(context: context, builder: (c) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Delete Folder?', style: TextStyle(color: Colors.white)), content: Text('Delete \"${folder['name']}\"?', style: const TextStyle(color: Colors.grey)), actions: [TextButton(onPressed: () => Navigator.pop(c, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(c, true), child: const Text('Delete'))]));\r\n                              if (ok == true) { try { await deleteFolder(fid); model.load(folderId: model.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e'))); } }\r\n                            },\r\n                          );\r\n                        }\r\n                        final filteredFiles = model.files.where((f) => _searchQuery.isEmpty || (f['title'] ?? f['name'] ?? '').toString().toLowerCase().contains(_searchQuery)).toList();\r\n                        final fi = i - model.folders.length;\r\n                        if (fi >= filteredFiles.length) return null;\r\n                        final item = filteredFiles[fi];\r\n                        final title = (item['title'] ?? item['name'] ?? 'Unknown').toString();\r\n                        final url = (item['file_url'] ?? item['url'] ?? '').toString();\r\n                        final id = (item['id'] ?? '').toString();\r\n                        final dur = item['duration_seconds'] ?? item['duration'];\r\n                        final typeLabel = item['source_type'] == 'tts' ? 'TTS' : item['source_type'] == 'upload' ? 'Upload' : item['source_type'] == 'recording' ? 'Recorded' : 'Audio';\r\n                        final enabled = item['enabled'] != false;\r\n                        return GestureDetector(\r\n                          onLongPress: () => showModalBottomSheet(context: context, backgroundColor: const Color(0xFF2A2A2A), builder: (c) => Column(mainAxisSize: MainAxisSize.min, children: [\r\n                            ListTile(leading: const Icon(Icons.edit, color: Colors.white), title: const Text('Rename', style: TextStyle(color: Colors.white)), onTap: () async { Navigator.pop(c); final ctrl = TextEditingController(text: title); final ok = await showDialog<bool>(context: context, builder: (d) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Rename', style: TextStyle(color: Colors.white)), content: TextField(controller: ctrl, style: const TextStyle(color: Colors.white), decoration: const InputDecoration(hintText: 'New title')), actions: [TextButton(onPressed: () => Navigator.pop(d, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(d, true), child: const Text('Save'))])); if (ok == true && ctrl.text.isNotEmpty) { try { await updateAnnouncement(id, title: ctrl.text); model.load(folderId: model.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e'))); } } }),\r\n                            ListTile(leading: Icon(enabled ? Icons.toggle_on : Icons.toggle_off, color: enabled ? const Color(0xFF1DB954) : Colors.grey), title: Text(enabled ? 'Disable' : 'Enable', style: const TextStyle(color: Colors.white)), onTap: () async { Navigator.pop(c); try { await updateAnnouncement(id, enabled: !enabled); model.load(folderId: model.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e'))); } }),\r\n                            ListTile(leading: const Icon(Icons.delete, color: Colors.red), title: const Text('Delete', style: TextStyle(color: Colors.red)), onTap: () async { Navigator.pop(c); final ok = await showDialog<bool>(context: context, builder: (d) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Delete?', style: TextStyle(color: Colors.white)), content: Text('Delete \"$title\"?', style: const TextStyle(color: Colors.grey)), actions: [TextButton(onPressed: () => Navigator.pop(d, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(d, true), child: const Text('Delete'))])); if (ok == true) { try { await deleteAnnouncementFile(id); model.load(folderId: model.currentFolderId); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e'))); } } }),\r\n                            ListTile(leading: const Icon(Icons.close, color: Colors.grey), title: const Text('Cancel', style: TextStyle(color: Colors.grey)), onTap: () => Navigator.pop(c)),\r\n                          ])),\r\n                          child: Container(\r\n                            margin: const EdgeInsets.only(bottom: 8),\r\n                            decoration: BoxDecoration(color: const Color(0xFF181818), borderRadius: BorderRadius.circular(8), border: Border.all(color: enabled ? Colors.transparent : Colors.red.withOpacity(0.3))),\r\n                            child: ListTile(\r\n                              leading: Container(width: 44, height: 44, decoration: BoxDecoration(color: const Color(0xFF282828), borderRadius: BorderRadius.circular(8)), child: const Icon(Icons.campaign, color: Color(0xFF1DB954), size: 24)),\r\n                              title: Text(title, maxLines: 1, overflow: TextOverflow.ellipsis, style: TextStyle(color: enabled ? Colors.white : Colors.grey, fontWeight: FontWeight.bold, fontSize: 14)),\r\n                              subtitle: Row(children: [\r\n                                Container(padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2), decoration: BoxDecoration(color: const Color(0xFF282828), borderRadius: BorderRadius.circular(4)), child: Text(typeLabel, style: const TextStyle(fontSize: 10, color: Colors.grey))),\r\n                                if (dur != null) ...[ const SizedBox(width: 6), Text('${(dur as num).toInt()}s', style: const TextStyle(fontSize: 11, color: Colors.grey)) ],\r\n                                if (!enabled) ...[ const SizedBox(width: 6), const Text('disabled', style: TextStyle(fontSize: 10, color: Colors.red)) ],\r\n                              ]),\r\n                              trailing: IconButton(\r\n                                icon: const Icon(Icons.play_circle_fill, color: Color(0xFF1DB954), size: 32),\r\n                                onPressed: url.isEmpty ? null : () => context.read<PlayerModel>().playUrl(url, title),\r\n                              ),\r\n                            ),\r\n                          ),\r\n                        );\r\n                      },\r\n                    ),\r\n                  ),\r\n                ),\r\n              ],\r\n            ),"
);

// ═══════════════════════════════════════════════════════════════
// FIX 12: Add _FolderListTile widget (replaces _FolderCard for list view)
// ═══════════════════════════════════════════════════════════════
apply('Add _FolderListTile widget after _FolderCard',
  "class _FileListItem extends StatelessWidget {",
  "class _FolderListTile extends StatelessWidget {\r\n  final String name;\r\n  final VoidCallback onTap;\r\n  final VoidCallback? onPlay;\r\n  final VoidCallback? onRename;\r\n  final VoidCallback? onDelete;\r\n  const _FolderListTile({required this.name, required this.onTap, this.onPlay, this.onRename, this.onDelete});\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onLongPress: () => showModalBottomSheet(context: context, backgroundColor: const Color(0xFF2A2A2A), builder: (c) => Column(mainAxisSize: MainAxisSize.min, children: [\r\n        ListTile(leading: const Icon(Icons.edit, color: Colors.white), title: const Text('Rename', style: TextStyle(color: Colors.white)), onTap: () { Navigator.pop(c); onRename?.call(); }),\r\n        ListTile(leading: const Icon(Icons.delete, color: Colors.red), title: const Text('Delete', style: TextStyle(color: Colors.red)), onTap: () { Navigator.pop(c); onDelete?.call(); }),\r\n        ListTile(leading: const Icon(Icons.close, color: Colors.grey), title: const Text('Cancel', style: TextStyle(color: Colors.grey)), onTap: () => Navigator.pop(c)),\r\n      ])),\r\n      child: Container(\r\n        margin: const EdgeInsets.only(bottom: 8),\r\n        decoration: BoxDecoration(color: const Color(0xFF1A1A1A), borderRadius: BorderRadius.circular(8)),\r\n        child: ListTile(\r\n          leading: const Icon(Icons.folder, color: Color(0xFF1DB954), size: 36),\r\n          title: Text(name, style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),\r\n          trailing: Row(mainAxisSize: MainAxisSize.min, children: [\r\n            if (onPlay != null) IconButton(icon: const Icon(Icons.play_circle_outline, color: Colors.white70), onPressed: onPlay, tooltip: 'Play all'),\r\n            const Icon(Icons.chevron_right, color: Colors.grey),\r\n          ]),\r\n          onTap: onTap,\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _FileListItem extends StatelessWidget {"
);

// ═══════════════════════════════════════════════════════════════
// FIX 13: Scheduler - show existing schedules list + delete
// ═══════════════════════════════════════════════════════════════
apply('Scheduler: add state to load and display schedules',
  "class SchedulerPage extends StatelessWidget {\r\n  const SchedulerPage({super.key});\r\n  @override\r\n  Widget build(BuildContext context) {",
  "class SchedulerPage extends StatefulWidget {\r\n  const SchedulerPage({super.key});\r\n  @override\r\n  State<SchedulerPage> createState() => _SchedulerPageState();\r\n}\r\nclass _SchedulerPageState extends State<SchedulerPage> {\r\n  List<dynamic> _schedules = [];\r\n  bool _loading = true;\r\n\r\n  @override\r\n  void initState() { super.initState(); _load(); }\r\n\r\n  Future<void> _load() async {\r\n    setState(() => _loading = true);\r\n    try {\r\n      final s = await getSchedules();\r\n      if (mounted) setState(() { _schedules = s; _loading = false; });\r\n    } catch (_) { if (mounted) setState(() => _loading = false); }\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {"
);

// Replace scheduler body with version showing existing schedules
apply('Scheduler: show existing schedules above create button',
  "      appBar: AppBar(title: const Text('Scheduler')),\r\n      body: Padding(\r\n        padding: const EdgeInsets.all(16),\r\n        child: Column(\r\n          crossAxisAlignment: CrossAxisAlignment.start,\r\n          children: [\r\n            Row(\r\n              mainAxisAlignment: MainAxisAlignment.spaceBetween,\r\n              children: [\r\n                const Text('Schedules', style: TextStyle(fontWeight: FontWeight.bold)),\r\n                FilledButton(",
  "      appBar: AppBar(title: const Text('Scheduler'), actions: [IconButton(icon: const Icon(Icons.refresh), onPressed: _load)]),\r\n      body: Column(\r\n        children: [\r\n          // Existing schedules\r\n          if (_loading) const LinearProgressIndicator(minHeight: 2),\r\n          if (_schedules.isNotEmpty) Expanded(\r\n            flex: 2,\r\n            child: Column(\r\n              crossAxisAlignment: CrossAxisAlignment.start,\r\n              children: [\r\n                const Padding(padding: EdgeInsets.fromLTRB(16,12,16,4), child: Text('ACTIVE SCHEDULES', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 12, color: Color(0xFF1DB954)))),\r\n                Expanded(child: ListView.builder(\r\n                  padding: const EdgeInsets.symmetric(horizontal: 12),\r\n                  itemCount: _schedules.length,\r\n                  itemBuilder: (ctx, i) {\r\n                    final s = _schedules[i];\r\n                    final rec = (s['recurrence'] ?? '').toString();\r\n                    final time = (s['time'] ?? s['time_of_day'] ?? '').toString();\r\n                    final annName = (s['announcement_title'] ?? s['announcement_name'] ?? s['folder_name'] ?? 'Unknown').toString();\r\n                    final sid = (s['id'] ?? '').toString();\r\n                    return Container(\r\n                      margin: const EdgeInsets.only(bottom: 8),\r\n                      decoration: BoxDecoration(color: const Color(0xFF1A1A1A), borderRadius: BorderRadius.circular(8)),\r\n                      child: ListTile(\r\n                        leading: const Icon(Icons.schedule, color: Color(0xFF1DB954)),\r\n                        title: Text(annName, style: const TextStyle(color: Colors.white, fontSize: 14)),\r\n                        subtitle: Text('$rec at $time', style: const TextStyle(color: Colors.grey, fontSize: 12)),\r\n                        trailing: IconButton(\r\n                          icon: const Icon(Icons.delete, color: Colors.red, size: 20),\r\n                          onPressed: () async {\r\n                            final ok = await showDialog<bool>(context: context, builder: (c) => AlertDialog(backgroundColor: const Color(0xFF2A2A2A), title: const Text('Delete Schedule?', style: TextStyle(color: Colors.white)), content: Text('Delete $rec schedule at $time?', style: const TextStyle(color: Colors.grey)), actions: [TextButton(onPressed: () => Navigator.pop(c, false), child: const Text('Cancel')), FilledButton(onPressed: () => Navigator.pop(c, true), child: const Text('Delete'))]));\r\n                            if (ok == true) { try { await deleteSchedule(sid); _load(); } catch (e) { if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Failed: $e'))); } }\r\n                          },\r\n                        ),\r\n                      ),\r\n                    );\r\n                  },\r\n                )),\r\n              ],\r\n            ),\r\n          ),\r\n          const Divider(height: 1),\r\n          Expanded(\r\n            flex: 3,\r\n            child: Padding(\r\n              padding: const EdgeInsets.all(16),\r\n              child: Column(\r\n                crossAxisAlignment: CrossAxisAlignment.start,\r\n                children: [\r\n                  Row(\r\n                    mainAxisAlignment: MainAxisAlignment.spaceBetween,\r\n                    children: [\r\n                      const Text('Create Schedule', style: TextStyle(fontWeight: FontWeight.bold)),\r\n                      FilledButton("
);

// Need to close the new Expanded properly - this requires matching the end of scheduler
// Let's find the existing schedule end pattern
apply('Scheduler: add import SharedPreferences - missing for persist',
  "import 'api.dart';",
  "import 'api.dart';\nimport 'package:shared_preferences/shared_preferences.dart';"
);

// Write the file
fs.writeFileSync(p + '.tmp', c, 'utf8');
console.log('\n=== DONE: ' + fixes + ' fixes applied ===');
console.log('Lines:', (c.match(/\n/g)||[]).length+1);

